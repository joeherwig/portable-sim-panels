// based on https://www.npmjs.com/package/fuzzball i extended my functions:

(function (f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.fuzzball = f() } })(function () {
    var define, module, exports; return function () { function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s } return e }()({
        1: [function (require, module, exports) { (function () { "use strict"; var SequenceMatcher = require("./lib/fbdifflib.js"); var Heap = require("heap"); var _intersect = require("./lib/lodash.custom.min.js").intersection; var _intersectWith = require("./lib/lodash.custom.min.js").intersectionWith; var _difference = require("./lib/lodash.custom.min.js").difference; var _differenceWith = require("./lib/lodash.custom.min.js").differenceWith; var _uniq = require("./lib/lodash.custom.min.js").uniq; var _uniqWith = require("./lib/lodash.custom.min.js").uniqWith; var _partialRight = require("./lib/lodash.custom.min.js").partialRight; var _forEach = require("./lib/lodash.custom.min.js").forEach; var _keys = require("./lib/lodash.custom.min.js").keys; var _isArray = require("./lib/lodash.custom.min.js").isArray; var _toArray = require("./lib/lodash.custom.min.js").toArray; var iLeven = require("./lib/iLeven.js"); var wildleven = require("./lib/wildcardLeven.js"); var leven = require("./lib/leven.js"); if (typeof setImmediate !== "function") require("setimmediate"); var utils = require("./lib/utils.js")(_uniq, _uniqWith, _partialRight); var validate = utils.validate; var process_and_sort = utils.process_and_sort; var tokenize = utils.tokenize; var full_process = utils.full_process; var clone_and_set_option_defaults = utils.clone_and_set_option_defaults; var isCustomFunc = utils.isCustomFunc; var processing = require("./lib/process.js")(clone_and_set_option_defaults, _isArray, QRatio, extract); var dedupe = processing.dedupe; function distance(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (typeof options.subcost === "undefined") options.subcost = 1; if (options.astral) return iLeven(str1, str2, options, _toArray); else return wildleven(str1, str2, options, leven) } function QRatio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (!validate(str1)) return 0; if (!validate(str2)) return 0; return _ratio(str1, str2, options) } function partial_ratio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (!validate(str1)) return 0; if (!validate(str2)) return 0; return _partial_ratio(str1, str2, options) } function token_set_ratio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (!validate(str1)) return 0; if (!validate(str2)) return 0; return _token_set(str1, str2, options) } function partial_token_set_ratio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (!validate(str1)) return 0; if (!validate(str2)) return 0; options.partial = true; return _token_set(str1, str2, options) } function token_sort_ratio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (!validate(str1)) return 0; if (!validate(str2)) return 0; if (!options.proc_sorted) { str1 = process_and_sort(str1); str2 = process_and_sort(str2) } return _ratio(str1, str2, options) } function partial_token_sort_ratio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; if (!validate(str1)) return 0; if (!validate(str2)) return 0; options.partial = true; if (!options.proc_sorted) { str1 = process_and_sort(str1); str2 = process_and_sort(str2) } return _partial_ratio(str1, str2, options) } function WRatio(str1, str2, options_p) { var options = clone_and_set_option_defaults(options_p); str1 = options.full_process ? full_process(str1, options) : str1; str2 = options.full_process ? full_process(str2, options) : str2; options.full_process = false; if (!validate(str1)) return 0; if (!validate(str2)) return 0; var try_partial = true; var unbase_scale = .95; var partial_scale = .9; var base = _ratio(str1, str2, options); var len_ratio = Math.max(str1.length, str2.length) / Math.min(str1.length, str2.length); if (len_ratio < 1.5) try_partial = false; if (len_ratio > 8) partial_scale = .6; if (try_partial) { var partial = _partial_ratio(str1, str2, options) * partial_scale; var ptsor = partial_token_sort_ratio(str1, str2, options) * unbase_scale * partial_scale; var ptser = partial_token_set_ratio(str1, str2, options) * unbase_scale * partial_scale; return Math.round(Math.max(base, partial, ptsor, ptser)) } else { var tsor = token_sort_ratio(str1, str2, options) * unbase_scale; var tser = token_set_ratio(str1, str2, options) * unbase_scale; return Math.round(Math.max(base, tsor, tser)) } } function extract(query, choices, options_p) { var options = clone_and_set_option_defaults(options_p); var numchoices; if (_isArray(choices)) { numchoices = choices.length } else if (!(choices instanceof Object)) { throw new Error("Invalid choices") } else numchoices = _keys(choices).length; if (!choices || numchoices === 0) { if (typeof console !== undefined) console.warn("No choices"); return [] } if (options.processor && typeof options.processor !== "function") { throw new Error("Invalid Processor") } if (!options.processor) options.processor = function (x) { return x }; if (options.scorer && typeof options.scorer !== "function") { throw new Error("Invalid Scorer") } if (!options.scorer) { options.scorer = QRatio } var isCustom = isCustomFunc(options.scorer); if (!options.cutoff || typeof options.cutoff !== "number") { options.cutoff = -1 } var pre_processor = function (choice, force_ascii) { return choice }; if (options.full_process) { pre_processor = full_process; if (!isCustom) options.processed = true } var normalize = false; if (!isCustom) { query = pre_processor(query, options); options.full_process = false; if (options.astral && options.normalize) { options.normalize = false; if (String.prototype.normalize) { normalize = true; query = query.normalize() } else { if (typeof console !== undefined) console.warn("Normalization not supported in your environment") } } if (query.length === 0) if (typeof console !== undefined) console.warn("Processed query is empty string") } var results = []; var anyblank = false; var tsort = false; var tset = false; if (options.scorer.name === "token_sort_ratio" || options.scorer.name === "partial_token_sort_ratio") { var proc_sorted_query = process_and_sort(query); tsort = true } else if (options.scorer.name === "token_set_ratio" || options.scorer.name === "partial_token_set_ratio") { var query_tokens = tokenize(query, options); tset = true } var result, mychoice, cmpHeap, cmpSort; if (options.returnObjects) { cmpHeap = function (a, b) { return a.score - b.score }; cmpSort = function (a, b) { return b.score - a.score } } else { cmpHeap = function (a, b) { return a[1] - b[1] }; cmpSort = function (a, b) { return b[1] - a[1] } } _forEach(choices, function (value, key) { options.tokens = undefined; options.proc_sorted = false; if (tsort) { options.proc_sorted = true; if (value && value.proc_sorted) mychoice = value.proc_sorted; else { mychoice = pre_processor(options.processor(value), options); mychoice = process_and_sort(normalize ? mychoice.normalize() : mychoice) } result = options.scorer(proc_sorted_query, mychoice, options) } else if (tset) { mychoice = "x"; if (value && value.tokens) { options.tokens = [query_tokens, value.tokens]; if (options.trySimple) mychoice = pre_processor(options.processor(value), options) } else { mychoice = pre_processor(options.processor(value), options); options.tokens = [query_tokens, tokenize(normalize ? mychoice.normalize() : mychoice, options)] } result = options.scorer(query, mychoice, options) } else if (isCustom) { mychoice = options.processor(value); result = options.scorer(query, mychoice, options) } else { mychoice = pre_processor(options.processor(value), options); if (typeof mychoice !== "string" || mychoice.length === 0) anyblank = true; if (normalize && typeof mychoice === "string") mychoice = mychoice.normalize(); result = options.scorer(query, mychoice, options) } if (result > options.cutoff) { if (options.returnObjects) results.push({ choice: value, score: result, key: key }); else results.push([value, result, key]) } }); if (anyblank) if (typeof console !== undefined) console.log("One or more choices were empty. (post-processing if applied)"); if (options.limit && typeof options.limit === "number" && options.limit > 0 && options.limit < numchoices && !options.unsorted) { results = Heap.nlargest(results, options.limit, cmpHeap) } else if (!options.unsorted) { results = results.sort(cmpSort) } return results } function extractAsync(query, choices, options_p, callback) { var options = clone_and_set_option_defaults(options_p); var cancelToken; if (typeof options_p.cancelToken === "object") { cancelToken = options_p.cancelToken } var loopOffset = 256; if (typeof options.asyncLoopOffset === "number") { if (options.asyncLoopOffset < 1) loopOffset = 1; else loopOffset = options.asyncLoopOffset } var isArray = false; var numchoices; if (choices && choices.length && _isArray(choices)) { numchoices = choices.length; isArray = true } else if (!(choices instanceof Object)) { callback(new Error("Invalid choices")); return } else numchoices = Object.keys(choices).length; if (!choices || numchoices === 0) { if (typeof console !== undefined) console.warn("No choices"); callback(null, []); return } if (options.processor && typeof options.processor !== "function") { callback(new Error("Invalid Processor")); return } if (!options.processor) options.processor = function (x) { return x }; if (options.scorer && typeof options.scorer !== "function") { callback(new Error("Invalid Scorer")); return } if (!options.scorer) { options.scorer = QRatio } var isCustom = isCustomFunc(options.scorer); if (!options.cutoff || typeof options.cutoff !== "number") { options.cutoff = -1 } var pre_processor = function (choice, force_ascii) { return choice }; if (options.full_process) { pre_processor = full_process; if (!isCustom) options.processed = true } var normalize = false; if (!isCustom) { query = pre_processor(query, options); options.full_process = false; if (options.astral && options.normalize) { options.normalize = false; if (String.prototype.normalize) { normalize = true; query = query.normalize() } else { if (typeof console !== undefined) console.warn("Normalization not supported in your environment") } } if (query.length === 0) if (typeof console !== undefined) console.warn("Processed query is empty string") } var results = []; var anyblank = false; var tsort = false; var tset = false; if (options.scorer.name === "token_sort_ratio" || options.scorer.name === "partial_token_sort_ratio") { var proc_sorted_query = process_and_sort(query); tsort = true } else if (options.scorer.name === "token_set_ratio" || options.scorer.name === "partial_token_set_ratio") { var query_tokens = tokenize(query, options); tset = true } var idx, mychoice, result, cmpHeap, cmpSort; if (options.returnObjects) { cmpHeap = function (a, b) { return a.score - b.score }; cmpSort = function (a, b) { return b.score - a.score } } else { cmpHeap = function (a, b) { return a[1] - b[1] }; cmpSort = function (a, b) { return b[1] - a[1] } } var keys = Object.keys(choices); isArray ? searchLoop(0) : searchLoop(keys[0], 0); function searchLoop(c, i) { if (isArray || choices.hasOwnProperty(c)) { options.tokens = undefined; options.proc_sorted = false; if (tsort) { options.proc_sorted = true; if (choices[c] && choices[c].proc_sorted) mychoice = choices[c].proc_sorted; else { mychoice = pre_processor(options.processor(choices[c]), options); mychoice = process_and_sort(normalize ? mychoice.normalize() : mychoice) } result = options.scorer(proc_sorted_query, mychoice, options) } else if (tset) { mychoice = "x"; if (choices[c] && choices[c].tokens) { options.tokens = [query_tokens, choices[c].tokens]; if (options.trySimple) mychoice = pre_processor(options.processor(choices[c]), options) } else { mychoice = pre_processor(options.processor(choices[c]), options); options.tokens = [query_tokens, tokenize(normalize ? mychoice.normalize() : mychoice, options)] } result = options.scorer(query, mychoice, options) } else if (isCustom) { mychoice = options.processor(choices[c]); result = options.scorer(query, mychoice, options) } else { mychoice = pre_processor(options.processor(choices[c]), options); if (typeof mychoice !== "string" || mychoice.length === 0) anyblank = true; if (normalize && typeof mychoice === "string") mychoice = mychoice.normalize(); result = options.scorer(query, mychoice, options) } if (isArray) idx = parseInt(c); else idx = c; if (result > options.cutoff) { if (options.returnObjects) results.push({ choice: choices[c], score: result, key: idx }); else results.push([choices[c], result, idx]) } } if (cancelToken && cancelToken.canceled === true) { callback(new Error("canceled")); return } if (isArray && c < choices.length - 1) { if (c % loopOffset === 0) { setImmediate(function () { searchLoop(c + 1) }) } else { searchLoop(c + 1) } } else if (i < keys.length - 1) { if (i % loopOffset === 0) { setImmediate(function () { searchLoop(keys[i + 1], i + 1) }) } else { searchLoop(keys[i + 1], i + 1) } } else { if (anyblank) if (typeof console !== undefined) console.log("One or more choices were empty. (post-processing if applied)"); if (options.limit && typeof options.limit === "number" && options.limit > 0 && options.limit < numchoices && !options.unsorted) { results = Heap.nlargest(results, options.limit, cmpHeap) } else if (!options.unsorted) { results = results.sort(cmpSort) } callback(null, results) } } } function _token_set(str1, str2, options) { if (!options.tokens) { var tokens1 = tokenize(str1, options); var tokens2 = tokenize(str2, options) } else { var tokens1 = options.tokens[0]; var tokens2 = options.tokens[1] } if (options.wildcards) { var partWild = _partialRight(wildleven, options, leven); var wildCompare = function (a, b) { return partWild(a, b) === 0 }; var intersection = _intersectWith(tokens1, tokens2, wildCompare); var diff1to2 = _differenceWith(tokens1, tokens2, wildCompare); var diff2to1 = _differenceWith(tokens2, tokens1, wildCompare) } else { var intersection = _intersect(tokens1, tokens2); var diff1to2 = _difference(tokens1, tokens2); var diff2to1 = _difference(tokens2, tokens1) } var sorted_sect = intersection.sort().join(" "); var sorted_1to2 = diff1to2.sort().join(" "); var sorted_2to1 = diff2to1.sort().join(" "); var combined_1to2 = sorted_sect + " " + sorted_1to2; var combined_2to1 = sorted_sect + " " + sorted_2to1; sorted_sect = sorted_sect.trim(); combined_1to2 = combined_1to2.trim(); combined_2to1 = combined_2to1.trim(); var ratio_func = _ratio; if (options.partial) { ratio_func = _partial_ratio; if (sorted_sect.length > 0) return 100 } var pairwise = [ratio_func(sorted_sect, combined_1to2, options), ratio_func(sorted_sect, combined_2to1, options), ratio_func(combined_1to2, combined_2to1, options)]; if (options.trySimple) { pairwise.push(ratio_func(str1, str2, options)) } return Math.max.apply(null, pairwise) } var normalWarn = false; function _ratio(str1, str2, options) { if (!validate(str1)) return 0; if (!validate(str2)) return 0; if (options.ratio_alg && options.ratio_alg === "difflib") { var m = new SequenceMatcher(null, str1, str2); var r = m.ratio(); return Math.round(100 * r) } if (typeof options.subcost === "undefined") options.subcost = 2; var levdistance, lensum; if (options.astral) { if (options.normalize) { if (String.prototype.normalize) { str1 = str1.normalize(); str2 = str2.normalize() } else { if (!normalWarn) { if (typeof console !== undefined) console.warn("Normalization not supported in your environment"); normalWarn = true } } } levdistance = iLeven(str1, str2, options, _toArray); lensum = _toArray(str1).length + _toArray(str2).length } else { if (!options.wildcards) { levdistance = leven(str1, str2, options); lensum = str1.length + str2.length } else { levdistance = wildleven(str1, str2, options, leven); lensum = str1.length + str2.length } } return Math.round(100 * ((lensum - levdistance) / lensum)) } function _partial_ratio(str1, str2, options) { if (!validate(str1)) return 0; if (!validate(str2)) return 0; if (str1.length <= str2.length) { var shorter = str1; var longer = str2 } else { var shorter = str2; var longer = str1 } var m = new SequenceMatcher(null, shorter, longer); var blocks = m.getMatchingBlocks(); var scores = []; for (var b = 0; b < blocks.length; b++) { var long_start = blocks[b][1] - blocks[b][0] > 0 ? blocks[b][1] - blocks[b][0] : 0; var long_end = long_start + shorter.length; var long_substr = longer.substring(long_start, long_end); var r = _ratio(shorter, long_substr, options); if (r > 99.5) return 100; else scores.push(r) } return Math.max.apply(null, scores) } if (!Object.keys) { Object.keys = function () { "use strict"; var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{ toString: null }.propertyIsEnumerable("toString"), dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], dontEnumsLength = dontEnums.length; return function (obj) { if (typeof obj !== "object" && (typeof obj !== "function" || obj === null)) { throw new TypeError("Object.keys called on non-object") } var result = [], prop, i; for (prop in obj) { if (hasOwnProperty.call(obj, prop)) { result.push(prop) } } if (hasDontEnumBug) { for (i = 0; i < dontEnumsLength; i++) { if (hasOwnProperty.call(obj, dontEnums[i])) { result.push(dontEnums[i]) } } } return result } }() } var extractAsPromised = undefined; if (typeof Promise !== "undefined") { extractAsPromised = function (query, choices, options) { return new Promise(function (resolve, reject) { extractAsync(query, choices, options, function (err, response) { if (err) reject(err); else resolve(response) }) }) } } var fuzzball = { distance: distance, ratio: QRatio, partial_ratio: partial_ratio, token_set_ratio: token_set_ratio, token_sort_ratio: token_sort_ratio, partial_token_set_ratio: partial_token_set_ratio, partial_token_sort_ratio: partial_token_sort_ratio, WRatio: WRatio, full_process: full_process, extract: extract, extractAsync: extractAsync, extractAsPromised: extractAsPromised, process_and_sort: process_and_sort, unique_tokens: tokenize, dedupe: dedupe }; module.exports = fuzzball })() }, { "./lib/fbdifflib.js": 2, "./lib/iLeven.js": 3, "./lib/leven.js": 4, "./lib/lodash.custom.min.js": 5, "./lib/process.js": 6, "./lib/utils.js": 7, "./lib/wildcardLeven.js": 8, heap: 13, setimmediate: 16 }], 2: [function (require, module, exports) { var floor = Math.floor, max = Math.max, min = Math.min; var _calculateRatio = function (matches, length) { if (length) { return 2 * matches / length } else { return 1 } }; var _arrayCmp = function (a, b) { var i, la, lb, _i, _ref, _ref1; _ref = [a.length, b.length], la = _ref[0], lb = _ref[1]; for (i = _i = 0, _ref1 = min(la, lb); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) { if (a[i] < b[i]) { return -1 } if (a[i] > b[i]) { return 1 } } return la - lb }; var _has = function (obj, key) { return Object.prototype.hasOwnProperty.call(obj, key) }; var _any = function (items) { var item, _i, _len; for (_i = 0, _len = items.length; _i < _len; _i++) { item = items[_i]; if (item) { return true } } return false }; var SequenceMatcher = function () { function SequenceMatcher(isjunk, a, b, autojunk) { this.isjunk = isjunk; if (a == null) { a = "" } if (b == null) { b = "" } this.autojunk = autojunk != null ? autojunk : true; this.a = this.b = null; this.setSeqs(a, b) } SequenceMatcher.prototype.setSeqs = function (a, b) { this.setSeq1(a); return this.setSeq2(b) }; SequenceMatcher.prototype.setSeq1 = function (a) { if (a === this.a) { return } this.a = a; return this.matchingBlocks = this.opcodes = null }; SequenceMatcher.prototype.setSeq2 = function (b) { if (b === this.b) { return } this.b = b; this.matchingBlocks = this.opcodes = null; this.fullbcount = null; return this._chainB() }; SequenceMatcher.prototype._chainB = function () { var b, b2j, elt, i, idxs, indices, isjunk, junk, n, ntest, popular, _i, _j, _len, _len1, _ref; b = this.b; this.b2j = b2j = {}; for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) { elt = b[i]; indices = _has(b2j, elt) ? b2j[elt] : b2j[elt] = []; indices.push(i) } junk = {}; isjunk = this.isjunk; if (isjunk) { _ref = Object.keys(b2j); for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) { elt = _ref[_j]; if (isjunk(elt)) { junk[elt] = true; delete b2j[elt] } } } popular = {}; n = b.length; if (this.autojunk && n >= 200) { ntest = floor(n / 100) + 1; for (elt in b2j) { idxs = b2j[elt]; if (idxs.length > ntest) { popular[elt] = true; delete b2j[elt] } } } this.isbjunk = function (b) { return _has(junk, b) }; return this.isbpopular = function (b) { return _has(popular, b) } }; SequenceMatcher.prototype.findLongestMatch = function (alo, ahi, blo, bhi) { var a, b, b2j, besti, bestj, bestsize, i, isbjunk, j, j2len, k, newj2len, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5; _ref = [this.a, this.b, this.b2j, this.isbjunk], a = _ref[0], b = _ref[1], b2j = _ref[2], isbjunk = _ref[3]; _ref1 = [alo, blo, 0], besti = _ref1[0], bestj = _ref1[1], bestsize = _ref1[2]; j2len = {}; for (i = _i = alo; alo <= ahi ? _i < ahi : _i > ahi; i = alo <= ahi ? ++_i : --_i) { newj2len = {}; _ref2 = _has(b2j, a[i]) ? b2j[a[i]] : []; for (_j = 0, _len = _ref2.length; _j < _len; _j++) { j = _ref2[_j]; if (j < blo) { continue } if (j >= bhi) { break } k = newj2len[j] = (j2len[j - 1] || 0) + 1; if (k > bestsize) { _ref3 = [i - k + 1, j - k + 1, k], besti = _ref3[0], bestj = _ref3[1], bestsize = _ref3[2] } } j2len = newj2len } while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) { _ref4 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref4[0], bestj = _ref4[1], bestsize = _ref4[2] } while (besti + bestsize < ahi && bestj + bestsize < bhi && !isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) { bestsize++ } while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) { _ref5 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref5[0], bestj = _ref5[1], bestsize = _ref5[2] } while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) { bestsize++ } return [besti, bestj, bestsize] }; SequenceMatcher.prototype.getMatchingBlocks = function () { var ahi, alo, bhi, blo, i, i1, i2, j, j1, j2, k, k1, k2, la, lb, matchingBlocks, nonAdjacent, queue, x, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4; if (this.matchingBlocks) { return this.matchingBlocks } _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1]; queue = [[0, la, 0, lb]]; matchingBlocks = []; while (queue.length) { _ref1 = queue.pop(), alo = _ref1[0], ahi = _ref1[1], blo = _ref1[2], bhi = _ref1[3]; _ref2 = x = this.findLongestMatch(alo, ahi, blo, bhi), i = _ref2[0], j = _ref2[1], k = _ref2[2]; if (k) { matchingBlocks.push(x); if (alo < i && blo < j) { queue.push([alo, i, blo, j]) } if (i + k < ahi && j + k < bhi) { queue.push([i + k, ahi, j + k, bhi]) } } } matchingBlocks.sort(_arrayCmp); i1 = j1 = k1 = 0; nonAdjacent = []; for (_i = 0, _len = matchingBlocks.length; _i < _len; _i++) { _ref3 = matchingBlocks[_i], i2 = _ref3[0], j2 = _ref3[1], k2 = _ref3[2]; if (i1 + k1 === i2 && j1 + k1 === j2) { k1 += k2 } else { if (k1) { nonAdjacent.push([i1, j1, k1]) } _ref4 = [i2, j2, k2], i1 = _ref4[0], j1 = _ref4[1], k1 = _ref4[2] } } if (k1) { nonAdjacent.push([i1, j1, k1]) } nonAdjacent.push([la, lb, 0]); return this.matchingBlocks = nonAdjacent }; SequenceMatcher.prototype.getOpcodes = function () { var ai, answer, bj, i, j, size, tag, _i, _len, _ref, _ref1, _ref2; if (this.opcodes) { return this.opcodes } i = j = 0; this.opcodes = answer = []; _ref = this.getMatchingBlocks(); for (_i = 0, _len = _ref.length; _i < _len; _i++) { _ref1 = _ref[_i], ai = _ref1[0], bj = _ref1[1], size = _ref1[2]; tag = ""; if (i < ai && j < bj) { tag = "replace" } else if (i < ai) { tag = "delete" } else if (j < bj) { tag = "insert" } if (tag) { answer.push([tag, i, ai, j, bj]) } _ref2 = [ai + size, bj + size], i = _ref2[0], j = _ref2[1]; if (size) { answer.push(["equal", ai, i, bj, j]) } } return answer }; SequenceMatcher.prototype.getGroupedOpcodes = function (n) { var codes, group, groups, i1, i2, j1, j2, nn, tag, _i, _len, _ref, _ref1, _ref2, _ref3; if (n == null) { n = 3 } codes = this.getOpcodes(); if (!codes.length) { codes = [["equal", 0, 1, 0, 1]] } if (codes[0][0] === "equal") { _ref = codes[0], tag = _ref[0], i1 = _ref[1], i2 = _ref[2], j1 = _ref[3], j2 = _ref[4]; codes[0] = [tag, max(i1, i2 - n), i2, max(j1, j2 - n), j2] } if (codes[codes.length - 1][0] === "equal") { _ref1 = codes[codes.length - 1], tag = _ref1[0], i1 = _ref1[1], i2 = _ref1[2], j1 = _ref1[3], j2 = _ref1[4]; codes[codes.length - 1] = [tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)] } nn = n + n; groups = []; group = []; for (_i = 0, _len = codes.length; _i < _len; _i++) { _ref2 = codes[_i], tag = _ref2[0], i1 = _ref2[1], i2 = _ref2[2], j1 = _ref2[3], j2 = _ref2[4]; if (tag === "equal" && i2 - i1 > nn) { group.push([tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)]); groups.push(group); group = []; _ref3 = [max(i1, i2 - n), max(j1, j2 - n)], i1 = _ref3[0], j1 = _ref3[1] } group.push([tag, i1, i2, j1, j2]) } if (group.length && !(group.length === 1 && group[0][0] === "equal")) { groups.push(group) } return groups }; SequenceMatcher.prototype.ratio = function () { var match, matches, _i, _len, _ref; matches = 0; _ref = this.getMatchingBlocks(); for (_i = 0, _len = _ref.length; _i < _len; _i++) { match = _ref[_i]; matches += match[2] } return _calculateRatio(matches, this.a.length + this.b.length) }; SequenceMatcher.prototype.quickRatio = function () { var avail, elt, fullbcount, matches, numb, _i, _j, _len, _len1, _ref, _ref1; if (!this.fullbcount) { this.fullbcount = fullbcount = {}; _ref = this.b; for (_i = 0, _len = _ref.length; _i < _len; _i++) { elt = _ref[_i]; fullbcount[elt] = (fullbcount[elt] || 0) + 1 } } fullbcount = this.fullbcount; avail = {}; matches = 0; _ref1 = this.a; for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) { elt = _ref1[_j]; if (_has(avail, elt)) { numb = avail[elt] } else { numb = fullbcount[elt] || 0 } avail[elt] = numb - 1; if (numb > 0) { matches++ } } return _calculateRatio(matches, this.a.length + this.b.length) }; SequenceMatcher.prototype.realQuickRatio = function () { var la, lb, _ref; _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1]; return _calculateRatio(min(la, lb), la + lb) }; return SequenceMatcher }(); module.exports = SequenceMatcher }, {}], 3: [function (require, module, exports) { require("string.prototype.codepointat"); require("string.fromcodepoint"); var collator; try { collator = typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined" ? Intl.Collator("generic", { sensitivity: "base" }) : null } catch (err) { if (typeof console !== undefined) console.warn("Collator could not be initialized and wouldn't be used") } module.exports = function leven(a, b, options, _toArray) { var arr = []; var charCodeCache = []; var useCollator = options && collator && options.useCollator; var subcost = 1; if (options && options.subcost && typeof options.subcost === "number") subcost = options.subcost; if (a === b) { return 0 } var achars = _toArray(a); var bchars = _toArray(b); var aLen = achars.length; var bLen = bchars.length; if (aLen === 0) { return bLen } if (bLen === 0) { return aLen } var bCharCode; var ret; var tmp; var tmp2; var i = 0; var j = 0; while (i < aLen) { charCodeCache[i] = achars[i].codePointAt(0); arr[i] = ++i } if (!useCollator) { while (j < bLen) { bCharCode = bchars[j].codePointAt(0); tmp = j++; ret = j; for (i = 0; i < aLen; i++) { tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + subcost; tmp = arr[i]; ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2 } } } else { while (j < bLen) { bCharCode = bchars[j].codePointAt(0); tmp = j++; ret = j; for (i = 0; i < aLen; i++) { tmp2 = 0 === collator.compare(String.fromCodePoint(bCharCode), String.fromCodePoint(charCodeCache[i])) ? tmp : tmp + subcost; tmp = arr[i]; ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2 } } } return ret } }, { "string.fromcodepoint": 17, "string.prototype.codepointat": 18 }], 4: [function (require, module, exports) { var collator; try { collator = typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined" ? Intl.Collator("generic", { sensitivity: "base" }) : null } catch (err) { if (typeof console !== undefined) console.warn("Collator could not be initialized and wouldn't be used") } module.exports = function leven(a, b, options) { var arr = []; var charCodeCache = []; var useCollator = options && collator && options.useCollator; var subcost = 1; if (options && options.subcost && typeof options.subcost === "number") subcost = options.subcost; if (a === b) { return 0 } var aLen = a.length; var bLen = b.length; if (aLen === 0) { return bLen } if (bLen === 0) { return aLen } var bCharCode; var ret; var tmp; var tmp2; var i = 0; var j = 0; while (i < aLen) { charCodeCache[i] = a.charCodeAt(i); arr[i] = ++i } if (!useCollator) { while (j < bLen) { bCharCode = b.charCodeAt(j); tmp = j++; ret = j; for (i = 0; i < aLen; i++) { tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + subcost; tmp = arr[i]; ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2 } } } else { while (j < bLen) { bCharCode = b.charCodeAt(j); tmp = j++; ret = j; for (i = 0; i < aLen; i++) { tmp2 = 0 === collator.compare(String.fromCharCode(bCharCode), String.fromCharCode(charCodeCache[i])) ? tmp : tmp + subcost; tmp = arr[i]; ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2 } } } return ret } }, {}], 5: [function (require, module, exports) {
            (function (global) {
                (function () {
                    function t(t, e, r) { switch (r.length) { case 0: return t.call(e); case 1: return t.call(e, r[0]); case 2: return t.call(e, r[0], r[1]); case 3: return t.call(e, r[0], r[1], r[2]) }return t.apply(e, r) } function e(t, e) { for (var r = -1, n = null == t ? 0 : t.length; ++r < n && false !== e(t[r], r, t);); return t } function r(t, e) { for (var r = -1, n = null == t ? 0 : t.length, u = 0, o = []; ++r < n;) { var i = t[r]; e(i, r, t) && (o[u++] = i) } return o } function n(t, e) { var r; if (r = !(null == t || !t.length)) { if (e === e) t: { r = -1; for (var n = t.length; ++r < n;)if (t[r] === e) break t; r = -1 } else t: { r = a; for (var n = t.length, u = -1; ++u < n;)if (r(t[u], u, t)) { r = u; break t } r = -1 } r = -1 < r } return r } function u(t, e, r) { for (var n = -1, u = null == t ? 0 : t.length; ++n < u;)if (r(e, t[n])) return true; return false } function o(t, e) { for (var r = -1, n = null == t ? 0 : t.length, u = Array(n); ++r < n;)u[r] = e(t[r], r, t); return u } function i(t, e) { for (var r = -1, n = e.length, u = t.length; ++r < n;)t[u + r] = e[r]; return t } function c(t, e) { for (var r = -1, n = null == t ? 0 : t.length; ++r < n;)if (e(t[r], r, t)) return true; return false } function a(t) { return t !== t } function f(t) { return function (e) { return null == e ? ae : e[t] } } function l(t) { return function (e) { return t(e) } } function s(t, e) { return o(e, function (e) { return t[e] }) } function h(t, e) { return t.has(e) } function b(t) { var e = -1, r = Array(t.size); return t.forEach(function (t, n) { r[++e] = [n, t] }), r } function p(t) { var e = Object; return function (r) { return t(e(r)) } } function y(t, e) { for (var r = -1, n = t.length, u = 0, o = []; ++r < n;) { var i = t[r]; i !== e && "__lodash_placeholder__" !== i || (t[r] = "__lodash_placeholder__", o[u++] = r) } return o } function _(t) { var e = -1, r = Array(t.size); return t.forEach(function (t) { r[++e] = t }), r } function g() { } function v(t) { this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = [] } function d(t) { var e = -1, r = null == t ? 0 : t.length; for (this.clear(); ++e < r;) { var n = t[e]; this.set(n[0], n[1]) } } function j(t) { var e = -1, r = null == t ? 0 : t.length; for (this.clear(); ++e < r;) { var n = t[e]; this.set(n[0], n[1]) } } function w(t) { var e = -1, r = null == t ? 0 : t.length; for (this.clear(); ++e < r;) { var n = t[e]; this.set(n[0], n[1]) } } function A(t) { var e = -1, r = null == t ? 0 : t.length; for (this.__data__ = new w; ++e < r;)this.add(t[e]) } function m(t) { this.size = (this.__data__ = new j(t)).size } function O(t, e) { var r = Xr(t), n = !r && Qr(t), u = !r && !n && Yr(t), o = !r && !n && !u && en(t); if (r = r || n || u || o) { for (var n = t.length, i = String, c = -1, a = Array(n); ++c < n;)a[c] = i(c); n = a } else n = []; var f, i = n.length; for (f in t) !e && !He.call(t, f) || r && ("length" == f || u && ("offset" == f || "parent" == f) || o && ("buffer" == f || "byteLength" == f || "byteOffset" == f) || Ot(f, i)) || n.push(f); return n } function S(t, e, r) { var n = t[e]; He.call(t, e) && Rt(n, r) && (r !== ae || e in t) || E(t, e, r) } function k(t, e) { for (var r = t.length; r--;)if (Rt(t[r][0], e)) return r; return -1 } function x(t, e) { return t && nt(e, Yt(e), t) } function z(t, e) { return t && nt(e, Zt(e), t) } function E(t, e, r) { "__proto__" == e && fr ? fr(t, e, { configurable: true, enumerable: true, value: r, writable: true }) : t[e] = r } function F(t, r, n, u, o, i) { var c, a = 1 & r, f = 2 & r, l = 4 & r; if (n && (c = o ? n(t, u, o, i) : n(t)), c !== ae) return c; if (!Tt(t)) return t; if (u = Xr(t)) { if (c = wt(t), !a) return rt(t, c) } else { var s = Nr(t), h = "[object Function]" == s || "[object GeneratorFunction]" == s; if (Yr(t)) return Y(t, a); if ("[object Object]" == s || "[object Arguments]" == s || h && !o) { if (c = f || h ? {} : typeof t.constructor != "function" || kt(t) ? {} : Mr(rr(t)), !a) return f ? ot(t, z(c, t)) : ut(t, x(c, t)) } else { if (!Ie[s]) return o ? t : {}; c = At(t, s, a) } } if (i || (i = new m), o = i.get(t)) return o; if (i.set(t, c), tn(t)) return t.forEach(function (e) { c.add(F(e, r, n, e, t, i)) }), c; if (Zr(t)) return t.forEach(function (e, u) { c.set(u, F(e, r, n, u, t, i)) }), c; var f = l ? f ? yt : pt : f ? Zt : Yt, b = u ? ae : f(t); return e(b || t, function (e, u) { b && (u = e, e = t[u]), S(c, u, F(e, r, n, u, t, i)) }), c } function I(t, e, r, i) { var c = -1, a = n, f = true, s = t.length, b = [], p = e.length; if (!s) return b; r && (e = o(e, l(r))), i ? (a = u, f = false) : 200 <= e.length && (a = h, f = false, e = new A(e)); t: for (; ++c < s;) { var y = t[c], _ = null == r ? y : r(y), y = i || 0 !== y ? y : 0; if (f && _ === _) { for (var g = p; g--;)if (e[g] === _) continue t; b.push(y) } else a(e, _, i) || b.push(y) } return b } function M(t, e, r, n, u) { var o = -1, c = t.length; for (r || (r = mt), u || (u = []); ++o < c;) { var a = t[o]; 0 < e && r(a) ? 1 < e ? M(a, e - 1, r, n, u) : i(u, a) : n || (u[u.length] = a) } return u } function $(t, e) { e = X(e, t); for (var r = 0, n = e.length; null != t && r < n;)t = t[It(e[r++])]; return r && r == n ? t : ae } function U(t, e, r) { return e = e(t), Xr(t) ? e : i(e, r(t)) } function B(t) {
                        if (null == t) t = t === ae ? "[object Undefined]" : "[object Null]"; else if (ar && ar in Object(t)) { var e = He.call(t, ar), r = t[ar]; try { t[ar] = ae; var n = true } catch (t) { } var u = Qe.call(t); n && (e ? t[ar] = r : delete t[ar]), t = u } else t = Qe.call(t); return t;

                    } function D(t, e, r) { for (var i = r ? u : n, c = t[0].length, a = t.length, f = a, s = Array(a), b = 1 / 0, p = []; f--;) { var y = t[f]; f && e && (y = o(y, l(e))), b = pr(y.length, b), s[f] = !r && (e || 120 <= c && 120 <= y.length) ? new A(f && y) : ae } var y = t[0], _ = -1, g = s[0]; t: for (; ++_ < c && p.length < b;) { var v = y[_], d = e ? e(v) : v, v = r || 0 !== v ? v : 0; if (g ? !h(g, d) : !i(p, d, r)) { for (f = a; --f;) { var j = s[f]; if (j ? !h(j, d) : !i(t[f], d, r)) continue t } g && g.push(d), p.push(v) } } return p } function R(t) { return Vt(t) && "[object Arguments]" == B(t) } function L(t, e, r, n, u) { if (t === e) e = true; else if (null == t || null == e || !Vt(t) && !Vt(e)) e = t !== t && e !== e; else t: { var o = Xr(t), i = Xr(e), c = o ? "[object Array]" : Nr(t), a = i ? "[object Array]" : Nr(e), c = "[object Arguments]" == c ? "[object Object]" : c, a = "[object Arguments]" == a ? "[object Object]" : a, f = "[object Object]" == c, i = "[object Object]" == a; if ((a = c == a) && Yr(t)) { if (!Yr(e)) { e = false; break t } o = true, f = false } if (a && !f) u || (u = new m), e = o || en(t) ? ht(t, e, r, n, L, u) : bt(t, e, c, r, n, L, u); else { if (!(1 & r) && (o = f && He.call(t, "__wrapped__"), c = i && He.call(e, "__wrapped__"), o || c)) { t = o ? t.value() : t, e = c ? e.value() : e, u || (u = new m), e = L(t, e, r, n, u); break t } if (a) e: if (u || (u = new m), o = 1 & r, c = pt(t), i = c.length, a = pt(e).length, i == a || o) { for (f = i; f--;) { var l = c[f]; if (!(o ? l in e : He.call(e, l))) { e = false; break e } } if ((a = u.get(t)) && u.get(e)) e = a == e; else { a = true, u.set(t, e), u.set(e, t); for (var s = o; ++f < i;) { var l = c[f], h = t[l], b = e[l]; if (n) var p = o ? n(b, h, l, e, t, u) : n(h, b, l, t, e, u); if (p === ae ? h !== b && !L(h, b, r, n, u) : !p) { a = false; break } s || (s = "constructor" == l) } a && !s && (r = t.constructor, n = e.constructor, r != n && "constructor" in t && "constructor" in e && !(typeof r == "function" && r instanceof r && typeof n == "function" && n instanceof n) && (a = false)), u.delete(t), u.delete(e), e = a } } else e = false; else e = false } } return e } function P(t) { return Vt(t) && "[object Map]" == Nr(t) } function C(t, e) { var r = e.length, n = r; if (null == t) return !n; for (t = Object(t); r--;) { var u = e[r]; if (u[2] ? u[1] !== t[u[0]] : !(u[0] in t)) return false } for (; ++r < n;) { var u = e[r], o = u[0], i = t[o], c = u[1]; if (u[2]) { if (i === ae && !(o in t)) return false } else if (u = new m, void 0 === ae ? !L(c, i, 3, void 0, u) : 1) return false } return true } function N(t) { return Vt(t) && "[object Set]" == Nr(t) } function T(t) { return Vt(t) && Nt(t.length) && !!Fe[B(t)] } function V(t) { return typeof t == "function" ? t : null == t ? re : typeof t == "object" ? Xr(t) ? q(t[0], t[1]) : W(t) : oe(t) } function W(t) { var e = dt(t); return 1 == e.length && e[0][2] ? xt(e[0][0], e[0][1]) : function (r) { return r === t || C(r, e) } } function q(t, e) { return St(t) && e === e && !Tt(e) ? xt(It(t), e) : function (r) { var n = Qt(r, t); return n === ae && n === e ? Xt(r, t) : L(e, n, 3) } } function G(t) { return function (e) { return $(e, t) } } function K(t) { return Vr(zt(t, re), t + "") } function H(t) { if (typeof t == "string") return t; if (Xr(t)) return o(t, H) + ""; if (qt(t)) return Ir ? Ir.call(t) : ""; var e = t + ""; return "0" == e && 1 / t == -fe ? "-0" : e } function J(t, e, r) { var o = -1, i = n, c = t.length, a = true, f = [], l = f; if (r) a = false, i = u; else if (200 <= c) { if (i = e ? null : Rr(t)) return _(i); a = false, i = h, l = new A } else l = e ? [] : f; t: for (; ++o < c;) { var s = t[o], b = e ? e(s) : s, s = r || 0 !== s ? s : 0; if (a && b === b) { for (var p = l.length; p--;)if (l[p] === b) continue t; e && l.push(b), f.push(s) } else i(l, b, r) || (l !== f && l.push(b), f.push(s)) } return f } function Q(t) { return Pt(t) ? t : [] } function X(t, e) { return Xr(t) ? t : St(t, e) ? [t] : Wr(Jt(t)) } function Y(t, e) { if (e) return t.slice(); var r = t.length, r = er ? er(r) : new t.constructor(r); return t.copy(r), r } function Z(t) { var e = new t.constructor(t.byteLength); return new tr(e).set(new tr(t)), e } function tt(t, e, r, n) { var u = -1, o = t.length, i = r.length, c = -1, a = e.length, f = br(o - i, 0), l = Array(a + f); for (n = !n; ++c < a;)l[c] = e[c]; for (; ++u < i;)(n || u < o) && (l[r[u]] = t[u]); for (; f--;)l[c++] = t[u++]; return l } function et(t, e, r, n) { var u = -1, o = t.length, i = -1, c = r.length, a = -1, f = e.length, l = br(o - c, 0), s = Array(l + f); for (n = !n; ++u < l;)s[u] = t[u]; for (l = u; ++a < f;)s[l + a] = e[a]; for (; ++i < c;)(n || u < o) && (s[l + r[i]] = t[u++]); return s } function rt(t, e) { var r = -1, n = t.length; for (e || (e = Array(n)); ++r < n;)e[r] = t[r]; return e } function nt(t, e, r) { var n = !r; r || (r = {}); for (var u = -1, o = e.length; ++u < o;) { var i = e[u], c = ae; c === ae && (c = t[i]), n ? E(r, i, c) : S(r, i, c) } return r } function ut(t, e) { return nt(t, Pr(t), e) } function ot(t, e) { return nt(t, Cr(t), e) } function it(t, e, r) { function n() { return (this && this !== De && this instanceof n ? o : t).apply(u ? r : this, arguments) } var u = 1 & e, o = ct(t); return n } function ct(t) { return function () { var e = arguments; switch (e.length) { case 0: return new t; case 1: return new t(e[0]); case 2: return new t(e[0], e[1]); case 3: return new t(e[0], e[1], e[2]); case 4: return new t(e[0], e[1], e[2], e[3]); case 5: return new t(e[0], e[1], e[2], e[3], e[4]); case 6: return new t(e[0], e[1], e[2], e[3], e[4], e[5]); case 7: return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6]) }var r = Mr(t.prototype), e = t.apply(r, e); return Tt(e) ? e : r } } function at(e, r, n) { function u() { for (var i = arguments.length, c = Array(i), a = i, f = _t(u); a--;)c[a] = arguments[a]; return a = 3 > i && c[0] !== f && c[i - 1] !== f ? [] : y(c, f), i -= a.length, i < n ? st(e, r, ft, u.placeholder, ae, c, a, ae, ae, n - i) : t(this && this !== De && this instanceof u ? o : e, this, c) } var o = ct(e); return u } function ft(t, e, r, n, u, o, i, c, a, f) { function l() { for (var v = arguments.length, d = Array(v), j = v; j--;)d[j] = arguments[j]; if (p) { var w, A = _t(l), j = d.length; for (w = 0; j--;)d[j] === A && ++w } if (n && (d = tt(d, n, u, p)), o && (d = et(d, o, i, p)), v -= w, p && v < f) return A = y(d, A), st(t, e, ft, l.placeholder, r, d, A, c, a, f - v); if (A = h ? r : this, j = b ? A[t] : t, v = d.length, c) { w = d.length; for (var m = pr(c.length, w), O = rt(d); m--;) { var S = c[m]; d[m] = Ot(S, w) ? O[S] : ae } } else _ && 1 < v && d.reverse(); return s && a < v && (d.length = a), this && this !== De && this instanceof l && (j = g || ct(j)), j.apply(A, d) } var s = 128 & e, h = 1 & e, b = 2 & e, p = 24 & e, _ = 512 & e, g = b ? ae : ct(t); return l } function lt(e, r, n, u) { function o() { for (var r = -1, a = arguments.length, f = -1, l = u.length, s = Array(l + a), h = this && this !== De && this instanceof o ? c : e; ++f < l;)s[f] = u[f]; for (; a--;)s[f++] = arguments[++r]; return t(h, i ? n : this, s) } var i = 1 & r, c = ct(e); return o } function st(t, e, r, n, u, o, i, c, a, f) { var l = 8 & e, s = l ? i : ae; i = l ? ae : i; var h = l ? o : ae; o = l ? ae : o, e = (e | (l ? 32 : 64)) & ~(l ? 64 : 32), 4 & e || (e &= -4), u = [t, e, u, h, s, o, i, c, a, f], r = r.apply(ae, u); t: for (c = t.name + "", a = mr[c], f = He.call(mr, c) ? a.length : 0; f--;)if (l = a[f], s = l.func, null == s || s == t) { c = l.name; break t } return a = g[c], typeof a == "function" && c in v.prototype ? t === a ? c = true : (c = Lr(a), c = !!c && t === c[0]) : c = false, c && Tr(r, u), r.placeholder = n, Et(r, t, e) } function ht(t, e, r, n, u, o) { var i = 1 & r, a = t.length, f = e.length; if (a != f && !(i && f > a)) return false; if ((f = o.get(t)) && o.get(e)) return f == e; var f = -1, l = true, s = 2 & r ? new A : ae; for (o.set(t, e), o.set(e, t); ++f < a;) { var b = t[f], p = e[f]; if (n) var y = i ? n(p, b, f, e, t, o) : n(b, p, f, t, e, o); if (y !== ae) { if (y) continue; l = false; break } if (s) { if (!c(e, function (t, e) { if (!h(s, e) && (b === t || u(b, t, r, n, o))) return s.push(e) })) { l = false; break } } else if (b !== p && !u(b, p, r, n, o)) { l = false; break } } return o.delete(t), o.delete(e), l } function bt(t, e, r, n, u, o, i) { switch (r) { case "[object DataView]": if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) break; t = t.buffer, e = e.buffer; case "[object ArrayBuffer]": if (t.byteLength != e.byteLength || !o(new tr(t), new tr(e))) break; return true; case "[object Boolean]": case "[object Date]": case "[object Number]": return Rt(+t, +e); case "[object Error]": return t.name == e.name && t.message == e.message; case "[object RegExp]": case "[object String]": return t == e + ""; case "[object Map]": var c = b; case "[object Set]": if (c || (c = _), t.size != e.size && !(1 & n)) break; return (r = i.get(t)) ? r == e : (n |= 2, i.set(t, e), e = ht(c(t), c(e), n, u, o, i), i.delete(t), e); case "[object Symbol]": if (Fr) return Fr.call(t) == Fr.call(e) }return false } function pt(t) { return U(t, Yt, Pr) } function yt(t) { return U(t, Zt, Cr) } function _t(t) { return (He.call(g, "placeholder") ? g : t).placeholder } function gt() { var t = g.iteratee || ne, t = t === ne ? V : t; return arguments.length ? t(arguments[0], arguments[1]) : t } function vt(t, e) { var r = t.__data__, n = typeof e; return ("string" == n || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== e : null === e) ? r[typeof e == "string" ? "string" : "hash"] : r.map } function dt(t) { for (var e = Yt(t), r = e.length; r--;) { var n = e[r], u = t[n]; e[r] = [n, u, u === u && !Tt(u)] } return e } function jt(t, e) { var r = null == t ? ae : t[e]; return (!Tt(r) || Je && Je in r ? 0 : (Ct(r) ? Xe : me).test(Mt(r))) ? r : ae } function wt(t) { var e = t.length, r = new t.constructor(e); return e && "string" == typeof t[0] && He.call(t, "index") && (r.index = t.index, r.input = t.input), r } function At(t, e, r) { var n = t.constructor; switch (e) { case "[object ArrayBuffer]": return Z(t); case "[object Boolean]": case "[object Date]": return new n(+t); case "[object DataView]": return e = r ? Z(t.buffer) : t.buffer, new t.constructor(e, t.byteOffset, t.byteLength); case "[object Float32Array]": case "[object Float64Array]": case "[object Int8Array]": case "[object Int16Array]": case "[object Int32Array]": case "[object Uint8Array]": case "[object Uint8ClampedArray]": case "[object Uint16Array]": case "[object Uint32Array]": return e = r ? Z(t.buffer) : t.buffer, new t.constructor(e, t.byteOffset, t.length); case "[object Map]": return new n; case "[object Number]": case "[object String]": return new n(t); case "[object RegExp]": return e = new t.constructor(t.source, je.exec(t)), e.lastIndex = t.lastIndex, e; case "[object Set]": return new n; case "[object Symbol]": return Fr ? Object(Fr.call(t)) : {} } } function mt(t) { return Xr(t) || Qr(t) || !!(ir && t && t[ir]) } function Ot(t, e) { var r = typeof t; return e = null == e ? 9007199254740991 : e, !!e && ("number" == r || "symbol" != r && Se.test(t)) && -1 < t && 0 == t % 1 && t < e } function St(t, e) { if (Xr(t)) return false; var r = typeof t; return !("number" != r && "symbol" != r && "boolean" != r && null != t && !qt(t)) || (be.test(t) || !he.test(t) || null != e && t in Object(e)) } function kt(t) { var e = t && t.constructor; return t === (typeof e == "function" && e.prototype || qe) } function xt(t, e) { return function (r) { return null != r && (r[t] === e && (e !== ae || t in Object(r))) } } function zt(e, r) { var n = void 0, n = br(n === ae ? e.length - 1 : n, 0); return function () { for (var u = arguments, o = -1, i = br(u.length - n, 0), c = Array(i); ++o < i;)c[o] = u[n + o]; for (o = -1, i = Array(n + 1); ++o < n;)i[o] = u[o]; return i[n] = r(c), t(e, this, i) } } function Et(t, e, r) { var n = e + ""; e = Vr; var u, o = $t; return u = (u = n.match(ge)) ? u[1].split(ve) : [], r = o(u, r), (o = r.length) && (u = o - 1, r[u] = (1 < o ? "& " : "") + r[u], r = r.join(2 < o ? ", " : " "), n = n.replace(_e, "{\n/* [wrapped with " + r + "] */\n")), e(t, n) } function Ft(t) { var e = 0, r = 0; return function () { var n = yr(), u = 16 - (n - r); if (r = n, 0 < u) { if (800 <= ++e) return arguments[0] } else e = 0; return t.apply(ae, arguments) } } function It(t) { if (typeof t == "string" || qt(t)) return t; var e = t + ""; return "0" == e && 1 / t == -fe ? "-0" : e } function Mt(t) { if (null != t) { try { return Ke.call(t) } catch (t) { } return t + "" } return "" } function $t(t, r) { return e(se, function (e) { var u = "_." + e[0]; r & e[1] && !n(t, u) && t.push(u) }), t.sort() } function Ut(t) { var e = null == t ? 0 : t.length; return e ? t[e - 1] : ae } function Bt(t, r) { return (Xr(t) ? e : $r)(t, gt(r, 3)) } function Dt(t, e) { function r() { var n = arguments, u = e ? e.apply(this, n) : n[0], o = r.cache; return o.has(u) ? o.get(u) : (n = t.apply(this, n), r.cache = o.set(u, n) || o, n) } if (typeof t != "function" || null != e && typeof e != "function") throw new TypeError("Expected a function"); return r.cache = new (Dt.Cache || w), r } function Rt(t, e) { return t === e || t !== t && e !== e } function Lt(t) { return null != t && Nt(t.length) && !Ct(t) } function Pt(t) { return Vt(t) && Lt(t) } function Ct(t) { return !!Tt(t) && (t = B(t), "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t) } function Nt(t) { return typeof t == "number" && -1 < t && 0 == t % 1 && 9007199254740991 >= t } function Tt(t) { var e = typeof t; return null != t && ("object" == e || "function" == e) } function Vt(t) { return null != t && typeof t == "object" } function Wt(t) { return typeof t == "string" || !Xr(t) && Vt(t) && "[object String]" == B(t) } function qt(t) { return typeof t == "symbol" || Vt(t) && "[object Symbol]" == B(t) } function Gt(t) { return t ? (t = Ht(t), t === fe || t === -fe ? 1.7976931348623157e308 * (0 > t ? -1 : 1) : t === t ? t : 0) : 0 === t ? t : 0 } function Kt(t) { t = Gt(t); var e = t % 1; return t === t ? e ? t - e : t : 0 } function Ht(t) { if (typeof t == "number") return t; if (qt(t)) return le; if (Tt(t) && (t = typeof t.valueOf == "function" ? t.valueOf() : t, t = Tt(t) ? t + "" : t), typeof t != "string") return 0 === t ? t : +t; t = t.replace(ye, ""); var e = Ae.test(t); return e || Oe.test(t) ? $e(t.slice(2), e ? 2 : 8) : we.test(t) ? le : +t } function Jt(t) { return null == t ? "" : H(t) } function Qt(t, e, r) { return t = null == t ? ae : $(t, e), t === ae ? r : t } function Xt(t, e) { var r; if (r = null != t) { r = t; var n; n = X(e, r); for (var u = -1, o = n.length, i = false; ++u < o;) { var c = It(n[u]); if (!(i = null != r && null != r && c in Object(r))) break; r = r[c] } i || ++u != o ? r = i : (o = null == r ? 0 : r.length, r = !!o && Nt(o) && Ot(c, o) && (Xr(r) || Qr(r))) } return r } function Yt(t) { if (Lt(t)) t = O(t); else if (kt(t)) { var e, r = []; for (e in Object(t)) He.call(t, e) && "constructor" != e && r.push(e); t = r } else t = hr(t); return t } function Zt(t) { if (Lt(t)) t = O(t, true); else if (Tt(t)) { var e, r = kt(t), n = []; for (e in t) ("constructor" != e || !r && He.call(t, e)) && n.push(e); t = n } else { if (e = [], null != t) for (r in Object(t)) e.push(r); t = e } return t } function te(t) { return null == t ? [] : s(t, Yt(t)) } function ee(t) { return function () { return t } } function re(t) { return t } function ne(t) { return V(typeof t == "function" ? t : F(t, 1)) } function ue() { } function oe(t) { return St(t) ? f(It(t)) : G(t) } function ie() { return [] } function ce() { return false } var ae, fe = 1 / 0, le = NaN, se = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], he = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, be = /^\w*$/, pe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ye = /^\s+|\s+$/g, _e = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ge = /\{\n\/\* \[wrapped with (.+)\] \*/, ve = /,? & /, de = /\\(\\)?/g, je = /\w*$/, we = /^[-+]0x[0-9a-f]+$/i, Ae = /^0b[01]+$/i, me = /^\[object .+?Constructor\]$/, Oe = /^0o[0-7]+$/i, Se = /^(?:0|[1-9]\d*)$/, ke = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*", xe = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])", ze = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + xe + ke, "g"), Ee = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"), Fe = {}; Fe["[object Float32Array]"] = Fe["[object Float64Array]"] = Fe["[object Int8Array]"] = Fe["[object Int16Array]"] = Fe["[object Int32Array]"] = Fe["[object Uint8Array]"] = Fe["[object Uint8ClampedArray]"] = Fe["[object Uint16Array]"] = Fe["[object Uint32Array]"] = true, Fe["[object Arguments]"] = Fe["[object Array]"] = Fe["[object ArrayBuffer]"] = Fe["[object Boolean]"] = Fe["[object DataView]"] = Fe["[object Date]"] = Fe["[object Error]"] = Fe["[object Function]"] = Fe["[object Map]"] = Fe["[object Number]"] = Fe["[object Object]"] = Fe["[object RegExp]"] = Fe["[object Set]"] = Fe["[object String]"] = Fe["[object WeakMap]"] = false; var Ie = {}; Ie["[object Arguments]"] = Ie["[object Array]"] = Ie["[object ArrayBuffer]"] = Ie["[object DataView]"] = Ie["[object Boolean]"] = Ie["[object Date]"] = Ie["[object Float32Array]"] = Ie["[object Float64Array]"] = Ie["[object Int8Array]"] = Ie["[object Int16Array]"] = Ie["[object Int32Array]"] = Ie["[object Map]"] = Ie["[object Number]"] = Ie["[object Object]"] = Ie["[object RegExp]"] = Ie["[object Set]"] = Ie["[object String]"] = Ie["[object Symbol]"] = Ie["[object Uint8Array]"] = Ie["[object Uint8ClampedArray]"] = Ie["[object Uint16Array]"] = Ie["[object Uint32Array]"] = true, Ie["[object Error]"] = Ie["[object Function]"] = Ie["[object WeakMap]"] = false; var Me, $e = parseInt, Ue = typeof global == "object" && global && global.Object === Object && global, Be = typeof self == "object" && self && self.Object === Object && self, De = Ue || Be || Function("return this")(), Re = typeof exports == "object" && exports && !exports.nodeType && exports, Le = Re && typeof module == "object" && module && !module.nodeType && module, Pe = Le && Le.exports === Re, Ce = Pe && Ue.process; t: { try { Me = Ce && Ce.binding && Ce.binding("util"); break t } catch (t) { } Me = void 0 } var Ne = Me && Me.isMap, Te = Me && Me.isSet, Ve = Me && Me.isTypedArray, We = Array.prototype, qe = Object.prototype, Ge = De["__core-js_shared__"], Ke = Function.prototype.toString, He = qe.hasOwnProperty, Je = function () { var t = /[^.]+$/.exec(Ge && Ge.keys && Ge.keys.IE_PROTO || ""); return t ? "Symbol(src)_1." + t : "" }(), Qe = qe.toString, Xe = RegExp("^" + Ke.call(He).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ye = Pe ? De.Buffer : ae, Ze = De.Symbol, tr = De.Uint8Array, er = Ye ? Ye.a : ae, rr = p(Object.getPrototypeOf), nr = Object.create, ur = qe.propertyIsEnumerable, or = We.splice, ir = Ze ? Ze.isConcatSpreadable : ae, cr = Ze ? Ze.iterator : ae, ar = Ze ? Ze.toStringTag : ae, fr = function () { try { var t = jt(Object, "defineProperty"); return t({}, "", {}), t } catch (t) { } }(), lr = Object.getOwnPropertySymbols, sr = Ye ? Ye.isBuffer : ae, hr = p(Object.keys), br = Math.max, pr = Math.min, yr = Date.now, _r = jt(De, "DataView"), gr = jt(De, "Map"), vr = jt(De, "Promise"), dr = jt(De, "Set"), jr = jt(De, "WeakMap"), wr = jt(Object, "create"), Ar = jr && new jr, mr = {}, Or = Mt(_r), Sr = Mt(gr), kr = Mt(vr), xr = Mt(dr), zr = Mt(jr), Er = Ze ? Ze.prototype : ae, Fr = Er ? Er.valueOf : ae, Ir = Er ? Er.toString : ae, Mr = function () { function t() { } return function (e) { return Tt(e) ? nr ? nr(e) : (t.prototype = e, e = new t, t.prototype = ae, e) : {} } }(); v.prototype = Mr(function () { }.prototype), v.prototype.constructor = v, d.prototype.clear = function () { this.__data__ = wr ? wr(null) : {}, this.size = 0 }, d.prototype.delete = function (t) { return t = this.has(t) && delete this.__data__[t], this.size -= t ? 1 : 0, t }, d.prototype.get = function (t) { var e = this.__data__; return wr ? (t = e[t], "__lodash_hash_undefined__" === t ? ae : t) : He.call(e, t) ? e[t] : ae }, d.prototype.has = function (t) { var e = this.__data__; return wr ? e[t] !== ae : He.call(e, t) }, d.prototype.set = function (t, e) { var r = this.__data__; return this.size += this.has(t) ? 0 : 1, r[t] = wr && e === ae ? "__lodash_hash_undefined__" : e, this }, j.prototype.clear = function () { this.__data__ = [], this.size = 0 }, j.prototype.delete = function (t) { var e = this.__data__; return t = k(e, t), !(0 > t) && (t == e.length - 1 ? e.pop() : or.call(e, t, 1), --this.size, true) }, j.prototype.get = function (t) { var e = this.__data__; return t = k(e, t), 0 > t ? ae : e[t][1] }, j.prototype.has = function (t) { return -1 < k(this.__data__, t) }, j.prototype.set = function (t, e) { var r = this.__data__, n = k(r, t); return 0 > n ? (++this.size, r.push([t, e])) : r[n][1] = e, this }, w.prototype.clear = function () { this.size = 0, this.__data__ = { hash: new d, map: new (gr || j), string: new d } }, w.prototype.delete = function (t) { return t = vt(this, t).delete(t), this.size -= t ? 1 : 0, t }, w.prototype.get = function (t) { return vt(this, t).get(t) }, w.prototype.has = function (t) { return vt(this, t).has(t) }, w.prototype.set = function (t, e) { var r = vt(this, t), n = r.size; return r.set(t, e), this.size += r.size == n ? 0 : 1, this }, A.prototype.add = A.prototype.push = function (t) { return this.__data__.set(t, "__lodash_hash_undefined__"), this }, A.prototype.has = function (t) { return this.__data__.has(t) }, m.prototype.clear = function () { this.__data__ = new j, this.size = 0 }, m.prototype.delete = function (t) { var e = this.__data__; return t = e.delete(t), this.size = e.size, t }, m.prototype.get = function (t) { return this.__data__.get(t) }, m.prototype.has = function (t) { return this.__data__.has(t) }, m.prototype.set = function (t, e) { var r = this.__data__; if (r instanceof j) { var n = r.__data__; if (!gr || 199 > n.length) return n.push([t, e]), this.size = ++r.size, this; r = this.__data__ = new w(n) } return r.set(t, e), this.size = r.size, this }; var $r = function (t, e) { return function (r, n) { if (null == r) return r; if (!Lt(r)) return t(r, n); for (var u = r.length, o = e ? u : -1, i = Object(r); (e ? o-- : ++o < u) && false !== n(i[o], o, i);); return r } }(function (t, e) { return t && Ur(t, e, Yt) }), Ur = function (t) { return function (e, r, n) { var u = -1, o = Object(e); n = n(e); for (var i = n.length; i--;) { var c = n[t ? i : ++u]; if (false === r(o[c], c, o)) break } return e } }(), Br = Ar ? function (t, e) { return Ar.set(t, e), t } : re, Dr = fr ? function (t, e) { return fr(t, "toString", { configurable: true, enumerable: false, value: ee(e), writable: true }) } : re, Rr = dr && 1 / _(new dr([, -0]))[1] == fe ? function (t) { return new dr(t) } : ue, Lr = Ar ? function (t) { return Ar.get(t) } : ue, Pr = lr ? function (t) { return null == t ? [] : (t = Object(t), r(lr(t), function (e) { return ur.call(t, e) })) } : ie, Cr = lr ? function (t) { for (var e = []; t;)i(e, Pr(t)), t = rr(t); return e } : ie, Nr = B; (_r && "[object DataView]" != Nr(new _r(new ArrayBuffer(1))) || gr && "[object Map]" != Nr(new gr) || vr && "[object Promise]" != Nr(vr.resolve()) || dr && "[object Set]" != Nr(new dr) || jr && "[object WeakMap]" != Nr(new jr)) && (Nr = function (t) { var e = B(t); if (t = (t = "[object Object]" == e ? t.constructor : ae) ? Mt(t) : "") switch (t) { case Or: return "[object DataView]"; case Sr: return "[object Map]"; case kr: return "[object Promise]"; case xr: return "[object Set]"; case zr: return "[object WeakMap]" }return e }); var Tr = Ft(Br), Vr = Ft(Dr), Wr = function (t) { t = Dt(t, function (t) { return 500 === e.size && e.clear(), t }); var e = t.cache; return t }(function (t) { var e = []; return 46 === t.charCodeAt(0) && e.push(""), t.replace(pe, function (t, r, n, u) { e.push(n ? u.replace(de, "$1") : r || t) }), e }), qr = K(function (t, e) { return Pt(t) ? I(t, M(e, 1, Pt, true)) : [] }), Gr = K(function (t, e) { var r = Ut(e); return Pt(r) && (r = ae), Pt(t) ? I(t, M(e, 1, Pt, true), ae, r) : [] }), Kr = K(function (t) { var e = o(t, Q); return e.length && e[0] === t[0] ? D(e) : [] }), Hr = K(function (t) { var e = Ut(t), r = o(t, Q); return (e = typeof e == "function" ? e : ae) && r.pop(), r.length && r[0] === t[0] ? D(r, ae, e) : [] }); Dt.Cache = w; var Jr = K(function (t, e) { var r, n, u = y(e, _t(Jr)), o = t, i = ae, c = e, a = u, f = 64, u = 2 & f; if (!u && typeof o != "function") throw new TypeError("Expected a function"); var l = c ? c.length : 0; if (l || (f &= -97, c = a = ae), r = r === ae ? r : br(Kt(r), 0), n = n === ae ? n : Kt(n), l -= a ? a.length : 0, 64 & f) var s = c, h = a, c = a = ae; var b = u ? ae : Lr(o); return r = [o, f, i, c, a, s, h, void 0, r, n], b && (c = r[1], o = b[1], i = c | o, n = 128 == o && 8 == c || 128 == o && 256 == c && r[7].length <= b[8] || 384 == o && b[7].length <= b[8] && 8 == c, 131 > i || n) && (1 & o && (r[2] = b[2], i |= 1 & c ? 0 : 4), (c = b[3]) && (n = r[3], r[3] = n ? tt(n, c, b[4]) : c, r[4] = n ? y(r[3], "__lodash_placeholder__") : b[4]), (c = b[5]) && (n = r[5], r[5] = n ? et(n, c, b[6]) : c, r[6] = n ? y(r[5], "__lodash_placeholder__") : b[6]), (c = b[7]) && (r[7] = c), 128 & o && (r[8] = null == r[8] ? b[8] : pr(r[8], b[8])), null == r[9] && (r[9] = b[9]), r[0] = b[0], r[1] = i), o = r[0], f = r[1], i = r[2], c = r[3], a = r[4], n = r[9] = r[9] === ae ? u ? 0 : o.length : br(r[9] - l, 0), !n && 24 & f && (f &= -25), Et((b ? Br : Tr)(f && 1 != f ? 8 == f || 16 == f ? at(o, f, n) : 32 != f && 33 != f || a.length ? ft.apply(ae, r) : lt(o, f, i, c) : it(o, f, i), r), o, f) }), Qr = R(function () { return arguments }()) ? R : function (t) { return Vt(t) && He.call(t, "callee") && !ur.call(t, "callee") }, Xr = Array.isArray, Yr = sr || ce, Zr = Ne ? l(Ne) : P, tn = Te ? l(Te) : N, en = Ve ? l(Ve) : T; g.constant = ee, g.difference = qr, g.differenceWith = Gr, g.intersection = Kr, g.intersectionWith = Hr, g.iteratee = ne, g.keys = Yt, g.keysIn = Zt, g.memoize = Dt, g.partialRight = Jr, g.property = oe, g.toArray = function (t) { if (!t) return []; if (Lt(t)) return Wt(t) ? Ee.test(t) ? t.match(ze) || [] : t.split("") : rt(t); if (cr && t[cr]) { t = t[cr](); for (var e, r = []; !(e = t.next()).done;)r.push(e.value); return r } return e = Nr(t), ("[object Map]" == e ? b : "[object Set]" == e ? _ : te)(t) }, g.uniq = function (t) { return t && t.length ? J(t) : [] }, g.uniqWith = function (t, e) { return e = typeof e == "function" ? e : ae, t && t.length ? J(t, ae, e) : [] }, g.values = te, g.eq = Rt, g.forEach = Bt, g.get = Qt, g.hasIn = Xt, g.identity = re, g.isArguments = Qr, g.isArray = Xr, g.isArrayLike = Lt, g.isArrayLikeObject = Pt, g.isBuffer = Yr, g.isFunction = Ct, g.isLength = Nt, g.isMap = Zr, g.isObject = Tt, g.isObjectLike = Vt, g.isSet = tn, g.isString = Wt, g.isSymbol = qt, g.isTypedArray = en, g.last = Ut, g.stubArray = ie, g.stubFalse = ce, g.noop = ue, g.toFinite = Gt, g.toInteger = Kt, g.toNumber = Ht, g.toString = Jt, g.each = Bt, g.VERSION = "4.17.5", Jr.placeholder = g, typeof define == "function" && typeof define.amd == "object" && define.amd ? (De._ = g, define(function () { return g })) : Le ? ((Le.exports = g)._ = g, Re._ = g) : De._ = g
                }).call(this)
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}], 6: [function (require, module, exports) { module.exports = function (_clone_and_set_option_defaults, _isArray, QRatio, extract) { module = {}; module.dedupe = function dedupe(contains_dupes, options_p) { var options = _clone_and_set_option_defaults(options_p); if (!(_isArray(contains_dupes) || typeof contains_dupes === "object")) { throw new Error("contains_dupes must be an array or object"); return } if (Object.keys(contains_dupes).length === 0) { if (typeof console !== undefined) console.warn("contains_dupes is empty"); return [] } if (options.limit) { if (typeof console !== undefined) console.warn("options.limit will be ignored in dedupe"); options.limit = 0 } if (!options.cutoff || typeof options.cutoff !== "number") { if (typeof console !== undefined) console.warn("Using default cutoff of 70"); options.cutoff = 70 } if (!options.scorer) { options.scorer = QRatio; if (typeof console !== undefined) console.log("Using default scorer 'ratio' for dedupe") } var processor; if (options.processor && typeof options.processor === "function") { processor = options.processor } else processor = function (x) { return x }; var uniqueItems = {}; for (var i in contains_dupes) { var item = processor(contains_dupes[i]); if (typeof item !== "string" && item instanceof String === false) { throw new Error("Each processed item in dedupe must be a string.") } var matches = extract(item, contains_dupes, options); if (options.returnObjects) { if (matches.length === 1) { if (options.keepmap) uniqueItems[processor(matches[0].choice)] = { item: matches[0].choice, key: matches[0].key, matches: matches }; else uniqueItems[processor(matches[0].choice)] = { item: matches[0].choice, key: matches[0].key } } else { matches = matches.sort(function (a, b) { var pa = processor(a.choice); var pb = processor(b.choice); var aLen = pa.length; var bLen = pb.length; if (aLen === bLen) { if (pa < pb) return -1; else return 1 } else return bLen - aLen }); if (options.keepmap) uniqueItems[processor(matches[0].choice)] = { item: matches[0].choice, key: matches[0].key, matches: matches }; else uniqueItems[processor(matches[0].choice)] = { item: matches[0].choice, key: matches[0].key } } } else { if (matches.length === 1) { if (options.keepmap) uniqueItems[processor(matches[0][0])] = [matches[0][0], matches[0][2], matches]; else uniqueItems[processor(matches[0][0])] = [matches[0][0], matches[0][2]] } else { matches = matches.sort(function (a, b) { var pa = processor(a[0]); var pb = processor(b[0]); var aLen = pa.length; var bLen = pb.length; if (aLen === bLen) { if (pa < pb) return -1; else return 1 } else return bLen - aLen }); if (options.keepmap) uniqueItems[processor(matches[0][0])] = [matches[0][0], matches[0][2], matches]; else uniqueItems[processor(matches[0][0])] = [matches[0][0], matches[0][2]] } } } var uniqueVals = []; for (var u in uniqueItems) { uniqueVals.push(uniqueItems[u]) } return uniqueVals }; return module } }, {}], 7: [function (require, module, exports) { module.exports = function (_uniq, _uniqWith, _partialRight) { var module = {}; var xre = require("./xregexp/index.js"); var wildLeven = require("./wildcardLeven.js"); var leven = require("./leven.js"); function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } function validate(str) { if ((typeof str === "string" || str instanceof String) && str.length > 0) return true; else return false } module.validate = validate; module.process_and_sort = function process_and_sort(str) { if (!validate(str)) return ""; return str.match(/\S+/g).sort().join(" ").trim() }; module.tokenize = function unique_tokens(str, options) { if (options && options.wildcards && _uniqWith && _partialRight) { var partWild = _partialRight(wildLeven, options, leven); var wildCompare = function (a, b) { return partWild(a, b) === 0 }; return _uniqWith(str.match(/\S+/g), wildCompare) } else return _uniq(str.match(/\S+/g)) }; var alphaNumUnicode = xre("[^\\pN|\\pL]", "g"); module.full_process = function full_process(str, options) { if (!(str instanceof String) && typeof str !== "string") return ""; var processedtext; if (options && typeof options === "object" && options.wildcards && typeof options.wildcards === "string" && options.wildcards.length > 0) { var wildcards = options.wildcards.toLowerCase(); str = str.toLowerCase(); if (options.force_ascii) { var pattern = "[^\x00 -|" + escapeRegExp(wildcards) + "]"; str = str.replace(new RegExp(pattern, "g"), ""); var wildpattern = "[" + escapeRegExp(wildcards) + "]"; var wildchar = wildcards[0]; str = str.replace(new RegExp(wildpattern, "g"), wildchar); var alphanumPat = "[^A-Za-z0-9" + escapeRegExp(wildcards) + "]"; str = str.replace(new RegExp(alphanumPat, "g"), " "); str = str.replace(/_/g, " "); processedtext = str.trim() } else { var upattern = "[^\\pN|\\pL|" + escapeRegExp(wildcards) + "]"; var alphaNumUnicodeWild = xre(upattern, "g"); str = xre.replace(str, alphaNumUnicodeWild, " ", "all"); var wildpattern = "[" + escapeRegExp(wildcards) + "]"; var wildchar = wildcards[0]; str = str.replace(new RegExp(wildpattern, "g"), wildchar); processedtext = str.trim() } } else { if (options && (options.force_ascii || options === true)) { str = str.replace(/[^\x00-\x7F]/g, ""); processedtext = str.replace(/\W|_/g, " ").toLowerCase().trim() } processedtext = xre.replace(str, alphaNumUnicode, " ", "all").toLowerCase().trim() } if (options && options.collapseWhitespace) { processedtext = processedtext.replace(/\s+/g, " ") } return processedtext }; module.clone_and_set_option_defaults = function (options) { if (options && options.isAClone) return options; var optclone = { isAClone: true }; if (options) { var i, keys = Object.keys(options); for (i = 0; i < keys.length; i++) { optclone[keys[i]] = options[keys[i]] } } if (!(typeof optclone.full_process !== "undefined" && optclone.full_process === false)) optclone.full_process = true; if (!(typeof optclone.force_ascii !== "undefined" && optclone.force_ascii === true)) optclone.force_ascii = false; if (!(typeof optclone.normalize !== "undefined" && optclone.normalize === false)) optclone.normalize = true; if (typeof optclone.astral !== "undefined" && optclone.astral === true) optclone.full_process = false; if (!(typeof optclone.collapseWhitespace !== "undefined" && optclone.collapseWhitespace === false)) optclone.collapseWhitespace = true; return optclone }; module.isCustomFunc = function (func) { if (typeof func === "function" && (func.name === "token_set_ratio" || func.name === "partial_token_set_ratio" || func.name === "token_sort_ratio" || func.name === "partial_token_sort_ratio" || func.name === "QRatio" || func.name === "WRatio" || func.name === "distance" || func.name === "partial_ratio")) { return false } else { return true } }; return module } }, { "./leven.js": 4, "./wildcardLeven.js": 8, "./xregexp/index.js": 9 }], 8: [function (require, module, exports) { var collator; try { collator = typeof Intl !== "undefined" && typeof Intl.Collator !== "undefined" ? Intl.Collator("generic", { sensitivity: "base" }) : null } catch (err) { if (typeof console !== undefined) console.warn("Collator could not be initialized and wouldn't be used") } module.exports = function leven(a, b, options, regLeven) { var arr = []; var charCodeCache = []; var useCollator = options && collator && options.useCollator; var subcost = 1; if (options && options.subcost && typeof options.subcost === "number") subcost = options.subcost; if (a === b) { return 0 } var aLen = a.length; var bLen = b.length; if (aLen === 0) { return bLen } if (bLen === 0) { return aLen } function escapeRegExp(string) { return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") } if (options && options.wildcards && typeof options.wildcards === "string" && options.wildcards.length > 0) { var wildchar; var wildcode; if (options.full_process === false && options.processed !== true) { wildchar = options.wildcards[0]; wildcode = wildchar.charCodeAt(0); var pattern = "[" + escapeRegExp(options.wildcards) + "]"; a = a.replace(new RegExp(pattern, "g"), wildchar); b = b.replace(new RegExp(pattern, "g"), wildchar); if (a === b) return 0 } else { wildchar = options.wildcards[0].toLowerCase(); wildcode = wildchar.charCodeAt(0) } var bCharCode; var ret; var tmp; var tmp2; var i = 0; var j = 0; while (i < aLen) { charCodeCache[i] = a.charCodeAt(i); arr[i] = ++i } if (!useCollator) { while (j < bLen) { bCharCode = b.charCodeAt(j); tmp = j++; ret = j; for (i = 0; i < aLen; i++) { tmp2 = bCharCode === charCodeCache[i] || bCharCode === wildcode || charCodeCache[i] === wildcode ? tmp : tmp + subcost; tmp = arr[i]; ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2 } } } else { while (j < bLen) { bCharCode = b.charCodeAt(j); tmp = j++; ret = j; for (i = 0; i < aLen; i++) { tmp2 = 0 === collator.compare(String.fromCharCode(bCharCode), String.fromCharCode(charCodeCache[i])) || bCharCode === wildcode || charCodeCache[i] === wildcode ? tmp : tmp + subcost; tmp = arr[i]; ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2 } } } return ret } else { return regLeven(a, b, options) } } }, {}], 9: [function (require, module, exports) { var XRegExp = require("./xregexp"); require("./unicode-base")(XRegExp); require("./unicode-categories")(XRegExp); module.exports = XRegExp }, { "./unicode-base": 10, "./unicode-categories": 11, "./xregexp": 12 }], 10: [function (require, module, exports) {
            module.exports = function (XRegExp) {
                "use strict"; var unicode = {}; var dec = XRegExp._dec; var hex = XRegExp._hex; var pad4 = XRegExp._pad4; function normalize(name) { return name.replace(/[- _]+/g, "").toLowerCase() } function charCode(chr) { var esc = /^\\[xu](.+)/.exec(chr); return esc ? dec(esc[1]) : chr.charCodeAt(chr.charAt(0) === "\\" ? 1 : 0) } function invertBmp(range) {
                    var output = ""; var lastEnd = -1; XRegExp.forEach(range, /(\\x..|\\u....|\\?[\s\S])(?:-(\\x..|\\u....|\\?[\s\S]))?/, function (m) { var start = charCode(m[1]); if (start > lastEnd + 1) { output += "\\u" + pad4(hex(lastEnd + 1)); if (start > lastEnd + 2) { output += "-\\u" + pad4(hex(start - 1)) } } lastEnd = charCode(m[2] || m[1]) }); if (lastEnd < 65535) {
                        output += "\\u" + pad4(hex(lastEnd + 1)); if (lastEnd < 65534) { output += "-\\uFFFF" }
                    } return output
                } function cacheInvertedBmp(slug) { var prop = "b!"; return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp)) } XRegExp.addToken(/\\([pP])(?:{(\^?)([^}]*)}|([A-Za-z]))/, function (match, scope, flags) { var ERR_DOUBLE_NEG = "Invalid double negation "; var ERR_UNKNOWN_NAME = "Unknown Unicode token "; var ERR_UNKNOWN_REF = "Unicode token missing data "; var ERR_ASTRAL_ONLY = "Astral mode required for Unicode token "; var ERR_ASTRAL_IN_CLASS = "Astral mode does not support Unicode tokens within character classes"; var isNegated = match[1] === "P" || !!match[2]; var slug = normalize(match[4] || match[3]); var item = unicode[slug]; if (match[1] === "P" && match[2]) { throw new SyntaxError(ERR_DOUBLE_NEG + match[0]) } if (!unicode.hasOwnProperty(slug)) { throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]) } if (item.inverseOf) { slug = normalize(item.inverseOf); if (!unicode.hasOwnProperty(slug)) { throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + " -> " + item.inverseOf) } item = unicode[slug]; isNegated = !isNegated } if (!item.bmp) { throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]) } return scope === "class" ? isNegated ? cacheInvertedBmp(slug) : item.bmp : (isNegated ? "[^" : "[") + item.bmp + "]" }, { scope: "all", optionalFlags: "A", leadChar: "\\" }); XRegExp.addUnicodeData = function (data) { var ERR_NO_NAME = "Unicode token requires name"; var ERR_NO_DATA = "Unicode token has no character data "; var item; for (var i = 0; i < data.length; ++i) { item = data[i]; if (!item.name) { throw new Error(ERR_NO_NAME) } if (!(item.inverseOf || item.bmp || item.astral)) { throw new Error(ERR_NO_DATA + item.name) } unicode[normalize(item.name)] = item; if (item.alias) { unicode[normalize(item.alias)] = item } } XRegExp.cache.flush("patterns") }; XRegExp._getUnicodeProperty = function (name) { var slug = normalize(name); return unicode[slug] }
            }
        }, {}], 11: [function (require, module, exports) { module.exports = function (XRegExp) { "use strict"; if (!XRegExp.addUnicodeData) { throw new ReferenceError("Unicode Base must be loaded before Unicode Categories") } XRegExp.addUnicodeData([{ name: "L", alias: "Letter", bmp: "A-Za-zªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛱ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢄᢇ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕℙ-ℝℤΩℨK-ℭℯ-ℹℼ-ℿⅅ-ⅉⅎↃↄⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞⸯ々〆〱-〵〻〼ぁ-ゖゝ-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛥꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-Ᶎꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭧꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ" }, { name: "N", alias: "Number", bmp: "0-9²³¹¼-¾٠-٩۰-۹߀-߉०-९০-৯৴-৹੦-੯૦-૯୦-୯୲-୷௦-௲౦-౯౸-౾೦-೯൘-൞൦-൸෦-෯๐-๙໐-໙༠-༳၀-၉႐-႙፩-፼ᛮ-ᛰ០-៩៰-៹᠐-᠙᥆-᥏᧐-᧚᪀-᪉᪐-᪙᭐-᭙᮰-᮹᱀-᱉᱐-᱙⁰⁴-⁹₀-₉⅐-ↂↅ-↉①-⒛⓪-⓿❶-➓⳽〇〡-〩〸-〺㆒-㆕㈠-㈩㉈-㉏㉑-㉟㊀-㊉㊱-㊿꘠-꘩ꛦ-ꛯ꠰-꠵꣐-꣙꤀-꤉꧐-꧙꧰-꧹꩐-꩙꯰-꯹０-９" }]) } }, {}], 12: [function (require, module, exports) { "use strict"; var REGEX_DATA = "xregexp"; var features = { astral: false, natives: false }; var nativ = { exec: RegExp.prototype.exec, test: RegExp.prototype.test, match: String.prototype.match, replace: String.prototype.replace, split: String.prototype.split }; var fixed = {}; var regexCache = {}; var patternCache = {}; var tokens = []; var defaultScope = "default"; var classScope = "class"; var nativeTokens = { "default": /\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/, "class": /\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/ }; var replacementToken = /\$(?:{([\w$]+)}|(\d\d?|[\s\S]))/g; var correctExecNpcg = nativ.exec.call(/()??/, "")[1] === undefined; var hasFlagsProp = /x/.flags !== undefined; var toString = {}.toString; function hasNativeFlag(flag) { var isSupported = true; try { new RegExp("", flag) } catch (exception) { isSupported = false } if (isSupported && flag === "y") { return new RegExp("aa|.", "y").test("b") } return isSupported } var hasNativeU = hasNativeFlag("u"); var hasNativeY = hasNativeFlag("y"); var registeredFlags = { g: true, i: true, m: true, u: hasNativeU, y: hasNativeY }; function augment(regex, captureNames, xSource, xFlags, isInternalOnly) { var p; regex[REGEX_DATA] = { captureNames: captureNames }; if (isInternalOnly) { return regex } if (regex.__proto__) { regex.__proto__ = XRegExp.prototype } else { for (p in XRegExp.prototype) { regex[p] = XRegExp.prototype[p] } } regex[REGEX_DATA].source = xSource; regex[REGEX_DATA].flags = xFlags ? xFlags.split("").sort().join("") : xFlags; return regex } function clipDuplicates(str) { return nativ.replace.call(str, /([\s\S])(?=[\s\S]*\1)/g, "") } function copyRegex(regex, options) { if (!XRegExp.isRegExp(regex)) { throw new TypeError("Type RegExp expected") } var xData = regex[REGEX_DATA] || {}, flags = getNativeFlags(regex), flagsToAdd = "", flagsToRemove = "", xregexpSource = null, xregexpFlags = null; options = options || {}; if (options.removeG) { flagsToRemove += "g" } if (options.removeY) { flagsToRemove += "y" } if (flagsToRemove) { flags = nativ.replace.call(flags, new RegExp("[" + flagsToRemove + "]+", "g"), "") } if (options.addG) { flagsToAdd += "g" } if (options.addY) { flagsToAdd += "y" } if (flagsToAdd) { flags = clipDuplicates(flags + flagsToAdd) } if (!options.isInternalOnly) { if (xData.source !== undefined) { xregexpSource = xData.source } if (xData.flags != null) { xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags } } regex = augment(new RegExp(options.source || regex.source, flags), hasNamedCapture(regex) ? xData.captureNames.slice(0) : null, xregexpSource, xregexpFlags, options.isInternalOnly); return regex } function dec(hex) { return parseInt(hex, 16) } function getNativeFlags(regex) { return hasFlagsProp ? regex.flags : nativ.exec.call(/\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1] } function hasNamedCapture(regex) { return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames) } function hex(dec) { return parseInt(dec, 10).toString(16) } function indexOf(array, value) { var len = array.length, i; for (i = 0; i < len; ++i) { if (array[i] === value) { return i } } return -1 } function isType(value, type) { return toString.call(value) === "[object " + type + "]" } function isQuantifierNext(pattern, pos, flags) { return nativ.test.call(flags.indexOf("x") > -1 ? /^(?:\s|#[^#\n]*|\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/ : /^(?:\(\?#[^)]*\))*(?:[?*+]|{\d+(?:,\d*)?})/, pattern.slice(pos)) } function pad4(str) { while (str.length < 4) { str = "0" + str } return str } function prepareFlags(pattern, flags) { var i; if (clipDuplicates(flags) !== flags) { throw new SyntaxError("Invalid duplicate regex flag " + flags) } pattern = nativ.replace.call(pattern, /^\(\?([\w$]+)\)/, function ($0, $1) { if (nativ.test.call(/[gy]/, $1)) { throw new SyntaxError("Cannot use flag g or y in mode modifier " + $0) } flags = clipDuplicates(flags + $1); return "" }); for (i = 0; i < flags.length; ++i) { if (!registeredFlags[flags.charAt(i)]) { throw new SyntaxError("Unknown regex flag " + flags.charAt(i)) } } return { pattern: pattern, flags: flags } } function registerFlag(flag) { if (!/^[\w$]$/.test(flag)) { throw new Error("Flag must be a single character A-Za-z0-9_$") } registeredFlags[flag] = true } function runTokens(pattern, flags, pos, scope, context) { var i = tokens.length, leadChar = pattern.charAt(pos), result = null, match, t; while (i--) { t = tokens[i]; if (t.leadChar && t.leadChar !== leadChar || t.scope !== scope && t.scope !== "all" || t.flag && flags.indexOf(t.flag) === -1) { continue } match = XRegExp.exec(pattern, t.regex, pos, "sticky"); if (match) { result = { matchLength: match[0].length, output: t.handler.call(context, match, scope, flags), reparse: t.reparse }; break } } return result } function setNatives(on) { RegExp.prototype.exec = (on ? fixed : nativ).exec; RegExp.prototype.test = (on ? fixed : nativ).test; String.prototype.match = (on ? fixed : nativ).match; String.prototype.replace = (on ? fixed : nativ).replace; String.prototype.split = (on ? fixed : nativ).split; features.natives = on } function toObject(value) { if (value == null) { throw new TypeError("Cannot convert null or undefined to object") } return value } function XRegExp(pattern, flags) { if (XRegExp.isRegExp(pattern)) { if (flags !== undefined) { throw new TypeError("Cannot supply flags when copying a RegExp") } return copyRegex(pattern) } pattern = pattern === undefined ? "" : String(pattern); flags = flags === undefined ? "" : String(flags); if (XRegExp.isInstalled("astral") && flags.indexOf("A") === -1) { flags += "A" } if (!patternCache[pattern]) { patternCache[pattern] = {} } if (!patternCache[pattern][flags]) { var context = { hasNamedCapture: false, captureNames: [] }; var scope = defaultScope; var output = ""; var pos = 0; var result; var applied = prepareFlags(pattern, flags); var appliedPattern = applied.pattern; var appliedFlags = applied.flags; while (pos < appliedPattern.length) { do { result = runTokens(appliedPattern, appliedFlags, pos, scope, context); if (result && result.reparse) { appliedPattern = appliedPattern.slice(0, pos) + result.output + appliedPattern.slice(pos + result.matchLength) } } while (result && result.reparse); if (result) { output += result.output; pos += result.matchLength || 1 } else { var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, "sticky")[0]; output += token; pos += token.length; if (token === "[" && scope === defaultScope) { scope = classScope } else if (token === "]" && scope === classScope) { scope = defaultScope } } } patternCache[pattern][flags] = { pattern: nativ.replace.call(output, /(?:\(\?:\))+/g, "(?:)"), flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ""), captures: context.hasNamedCapture ? context.captureNames : null } } var generated = patternCache[pattern][flags]; return augment(new RegExp(generated.pattern, generated.flags), generated.captures, pattern, flags) } XRegExp.prototype = new RegExp; XRegExp.version = "3.1.1-next"; XRegExp._clipDuplicates = clipDuplicates; XRegExp._hasNativeFlag = hasNativeFlag; XRegExp._dec = dec; XRegExp._hex = hex; XRegExp._pad4 = pad4; XRegExp.addToken = function (regex, handler, options) { options = options || {}; var optionalFlags = options.optionalFlags, i; if (options.flag) { registerFlag(options.flag) } if (optionalFlags) { optionalFlags = nativ.split.call(optionalFlags, ""); for (i = 0; i < optionalFlags.length; ++i) { registerFlag(optionalFlags[i]) } } tokens.push({ regex: copyRegex(regex, { addG: true, addY: hasNativeY, isInternalOnly: true }), handler: handler, scope: options.scope || defaultScope, flag: options.flag, reparse: options.reparse, leadChar: options.leadChar }); XRegExp.cache.flush("patterns") }; XRegExp.cache = function (pattern, flags) { if (!regexCache[pattern]) { regexCache[pattern] = {} } return regexCache[pattern][flags] || (regexCache[pattern][flags] = XRegExp(pattern, flags)) }; XRegExp.cache.flush = function (cacheName) { if (cacheName === "patterns") { patternCache = {} } else { regexCache = {} } }; XRegExp.exec = function (str, regex, pos, sticky) { var cacheKey = "g", addY = false, fakeY = false, match, r2; addY = hasNativeY && !!(sticky || regex.sticky && sticky !== false); if (addY) { cacheKey += "y" } else if (sticky) { fakeY = true; cacheKey += "FakeY" } regex[REGEX_DATA] = regex[REGEX_DATA] || {}; r2 = regex[REGEX_DATA][cacheKey] || (regex[REGEX_DATA][cacheKey] = copyRegex(regex, { addG: true, addY: addY, source: fakeY ? regex.source + "|()" : undefined, removeY: sticky === false, isInternalOnly: true })); pos = pos || 0; r2.lastIndex = pos; match = fixed.exec.call(r2, str); if (fakeY && match && match.pop() === "") { match = null } if (regex.global) { regex.lastIndex = match ? r2.lastIndex : 0 } return match }; XRegExp.isInstalled = function (feature) { return !!features[feature] }; XRegExp.isRegExp = function (value) { return toString.call(value) === "[object RegExp]" }; XRegExp.replace = function (str, search, replacement, scope) { var isRegex = XRegExp.isRegExp(search), global = search.global && scope !== "one" || scope === "all", cacheKey = (global ? "g" : "") + (search.sticky ? "y" : "") || "noGY", s2 = search, result; if (isRegex) { search[REGEX_DATA] = search[REGEX_DATA] || {}; s2 = search[REGEX_DATA][cacheKey] || (search[REGEX_DATA][cacheKey] = copyRegex(search, { addG: !!global, removeG: scope === "one", isInternalOnly: true })) } else if (global) { s2 = new RegExp(XRegExp.escape(String(search)), "g") } result = fixed.replace.call(toObject(str), s2, replacement); if (isRegex && search.global) { search.lastIndex = 0 } return result }; fixed.exec = function (str) { var origLastIndex = this.lastIndex, match = nativ.exec.apply(this, arguments), name, r2, i; if (match) { if (!correctExecNpcg && match.length > 1 && indexOf(match, "") > -1) { r2 = copyRegex(this, { removeG: true, isInternalOnly: true }); nativ.replace.call(String(str).slice(match.index), r2, function () { var len = arguments.length, i; for (i = 1; i < len - 2; ++i) { if (arguments[i] === undefined) { match[i] = undefined } } }) } if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) { for (i = 1; i < match.length; ++i) { name = this[REGEX_DATA].captureNames[i - 1]; if (name) { match[name] = match[i] } } } if (this.global && !match[0].length && this.lastIndex > match.index) { this.lastIndex = match.index } } if (!this.global) { this.lastIndex = origLastIndex } return match }; fixed.replace = function (search, replacement) { var isRegex = XRegExp.isRegExp(search), origLastIndex, captureNames, result; if (isRegex) { if (search[REGEX_DATA]) { captureNames = search[REGEX_DATA].captureNames } origLastIndex = search.lastIndex } else { search += "" } if (isType(replacement, "Function")) { result = nativ.replace.call(String(this), search, function () { var args = arguments, i; if (captureNames) { args[0] = new String(args[0]); for (i = 0; i < captureNames.length; ++i) { if (captureNames[i]) { args[0][captureNames[i]] = args[i + 1] } } } if (isRegex && search.global) { search.lastIndex = args[args.length - 2] + args[0].length } return replacement.apply(undefined, args) }) } else { result = nativ.replace.call(this == null ? this : String(this), search, function () { var args = arguments; return nativ.replace.call(String(replacement), replacementToken, function ($0, $1, $2) { var n; if ($1) { n = +$1; if (n <= args.length - 3) { return args[n] || "" } n = captureNames ? indexOf(captureNames, $1) : -1; if (n < 0) { throw new SyntaxError("Backreference to undefined group " + $0) } return args[n + 1] || "" } if ($2 === "$") { return "$" } if ($2 === "&" || +$2 === 0) { return args[0] } if ($2 === "`") { return args[args.length - 1].slice(0, args[args.length - 2]) } if ($2 === "'") { return args[args.length - 1].slice(args[args.length - 2] + args[0].length) } $2 = +$2; if (!isNaN($2)) { if ($2 > args.length - 3) { throw new SyntaxError("Backreference to undefined group " + $0) } return args[$2] || "" } throw new SyntaxError("Invalid token " + $0) }) }) } if (isRegex) { if (search.global) { search.lastIndex = 0 } else { search.lastIndex = origLastIndex } } return result }; fixed.split = function (separator, limit) { if (!XRegExp.isRegExp(separator)) { return nativ.split.apply(this, arguments) } var str = String(this), output = [], origLastIndex = separator.lastIndex, lastLastIndex = 0, lastLength; limit = (limit === undefined ? -1 : limit) >>> 0; XRegExp.forEach(str, separator, function (match) { if (match.index + match[0].length > lastLastIndex) { output.push(str.slice(lastLastIndex, match.index)); if (match.length > 1 && match.index < str.length) { Array.prototype.push.apply(output, match.slice(1)) } lastLength = match[0].length; lastLastIndex = match.index + lastLength } }); if (lastLastIndex === str.length) { if (!nativ.test.call(separator, "") || lastLength) { output.push("") } } else { output.push(str.slice(lastLastIndex)) } separator.lastIndex = origLastIndex; return output.length > limit ? output.slice(0, limit) : output }; XRegExp.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/, function (match, scope) { if (match[1] === "B" && scope === defaultScope) { return match[0] } throw new SyntaxError("Invalid escape " + match[0]) }, { scope: "all", leadChar: "\\" }); XRegExp.addToken(/\\u{([\dA-Fa-f]+)}/, function (match, scope, flags) { var code = dec(match[1]); if (code > 1114111) { throw new SyntaxError("Invalid Unicode code point " + match[0]) } if (code <= 65535) { return "\\u" + pad4(hex(code)) } if (hasNativeU && flags.indexOf("u") > -1) { return match[0] } throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u") }, { scope: "all", leadChar: "\\" }); XRegExp.addToken(/\[(\^?)\]/, function (match) { return match[1] ? "[\\s\\S]" : "\\b\\B" }, { leadChar: "[" }); XRegExp.addToken(/\(\?#[^)]*\)/, function (match, scope, flags) { return isQuantifierNext(match.input, match.index + match[0].length, flags) ? "" : "(?:)" }, { leadChar: "(" }); XRegExp.addToken(/\s+|#[^\n]*\n?/, function (match, scope, flags) { return isQuantifierNext(match.input, match.index + match[0].length, flags) ? "" : "(?:)" }, { flag: "x" }); XRegExp.addToken(/\./, function () { return "[\\s\\S]" }, { flag: "s", leadChar: "." }); XRegExp.addToken(/\\k<([\w$]+)>/, function (match) { var index = isNaN(match[1]) ? indexOf(this.captureNames, match[1]) + 1 : +match[1], endIndex = match.index + match[0].length; if (!index || index > this.captureNames.length) { throw new SyntaxError("Backreference to undefined group " + match[0]) } return "\\" + index + (endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ? "" : "(?:)") }, { leadChar: "\\" }); XRegExp.addToken(/\\(\d+)/, function (match, scope) { if (!(scope === defaultScope && /^[1-9]/.test(match[1]) && +match[1] <= this.captureNames.length) && match[1] !== "0") { throw new SyntaxError("Cannot use octal escape or backreference to undefined group " + match[0]) } return match[0] }, { scope: "all", leadChar: "\\" }); XRegExp.addToken(/\(\?P?<([\w$]+)>/, function (match) { if (!isNaN(match[1])) { throw new SyntaxError("Cannot use integer as capture name " + match[0]) } if (match[1] === "length" || match[1] === "__proto__") { throw new SyntaxError("Cannot use reserved word as capture name " + match[0]) } if (indexOf(this.captureNames, match[1]) > -1) { throw new SyntaxError("Cannot use same name for multiple groups " + match[0]) } this.captureNames.push(match[1]); this.hasNamedCapture = true; return "(" }, { leadChar: "(" }); XRegExp.addToken(/\((?!\?)/, function (match, scope, flags) { if (flags.indexOf("n") > -1) { return "(?:" } this.captureNames.push(null); return "(" }, { optionalFlags: "n", leadChar: "(" }); module.exports = XRegExp }, {}], 13: [function (require, module, exports) { module.exports = require("./lib/heap") }, { "./lib/heap": 14 }], 14: [function (require, module, exports) { (function () { var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup; floor = Math.floor, min = Math.min; defaultCmp = function (x, y) { if (x < y) { return -1 } if (x > y) { return 1 } return 0 }; insort = function (a, x, lo, hi, cmp) { var mid; if (lo == null) { lo = 0 } if (cmp == null) { cmp = defaultCmp } if (lo < 0) { throw new Error("lo must be non-negative") } if (hi == null) { hi = a.length } while (lo < hi) { mid = floor((lo + hi) / 2); if (cmp(x, a[mid]) < 0) { hi = mid } else { lo = mid + 1 } } return [].splice.apply(a, [lo, lo - lo].concat(x)), x }; heappush = function (array, item, cmp) { if (cmp == null) { cmp = defaultCmp } array.push(item); return _siftdown(array, 0, array.length - 1, cmp) }; heappop = function (array, cmp) { var lastelt, returnitem; if (cmp == null) { cmp = defaultCmp } lastelt = array.pop(); if (array.length) { returnitem = array[0]; array[0] = lastelt; _siftup(array, 0, cmp) } else { returnitem = lastelt } return returnitem }; heapreplace = function (array, item, cmp) { var returnitem; if (cmp == null) { cmp = defaultCmp } returnitem = array[0]; array[0] = item; _siftup(array, 0, cmp); return returnitem }; heappushpop = function (array, item, cmp) { var _ref; if (cmp == null) { cmp = defaultCmp } if (array.length && cmp(array[0], item) < 0) { _ref = [array[0], item], item = _ref[0], array[0] = _ref[1]; _siftup(array, 0, cmp) } return item }; heapify = function (array, cmp) { var i, _i, _j, _len, _ref, _ref1, _results, _results1; if (cmp == null) { cmp = defaultCmp } _ref1 = function () { _results1 = []; for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) { _results1.push(_j) } return _results1 }.apply(this).reverse(); _results = []; for (_i = 0, _len = _ref1.length; _i < _len; _i++) { i = _ref1[_i]; _results.push(_siftup(array, i, cmp)) } return _results }; updateItem = function (array, item, cmp) { var pos; if (cmp == null) { cmp = defaultCmp } pos = array.indexOf(item); if (pos === -1) { return } _siftdown(array, 0, pos, cmp); return _siftup(array, pos, cmp) }; nlargest = function (array, n, cmp) { var elem, result, _i, _len, _ref; if (cmp == null) { cmp = defaultCmp } result = array.slice(0, n); if (!result.length) { return result } heapify(result, cmp); _ref = array.slice(n); for (_i = 0, _len = _ref.length; _i < _len; _i++) { elem = _ref[_i]; heappushpop(result, elem, cmp) } return result.sort(cmp).reverse() }; nsmallest = function (array, n, cmp) { var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results; if (cmp == null) { cmp = defaultCmp } if (n * 10 <= array.length) { result = array.slice(0, n).sort(cmp); if (!result.length) { return result } los = result[result.length - 1]; _ref = array.slice(n); for (_i = 0, _len = _ref.length; _i < _len; _i++) { elem = _ref[_i]; if (cmp(elem, los) < 0) { insort(result, elem, 0, null, cmp); result.pop(); los = result[result.length - 1] } } return result } heapify(array, cmp); _results = []; for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) { _results.push(heappop(array, cmp)) } return _results }; _siftdown = function (array, startpos, pos, cmp) { var newitem, parent, parentpos; if (cmp == null) { cmp = defaultCmp } newitem = array[pos]; while (pos > startpos) { parentpos = pos - 1 >> 1; parent = array[parentpos]; if (cmp(newitem, parent) < 0) { array[pos] = parent; pos = parentpos; continue } break } return array[pos] = newitem }; _siftup = function (array, pos, cmp) { var childpos, endpos, newitem, rightpos, startpos; if (cmp == null) { cmp = defaultCmp } endpos = array.length; startpos = pos; newitem = array[pos]; childpos = 2 * pos + 1; while (childpos < endpos) { rightpos = childpos + 1; if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) { childpos = rightpos } array[pos] = array[childpos]; pos = childpos; childpos = 2 * pos + 1 } array[pos] = newitem; return _siftdown(array, startpos, pos, cmp) }; Heap = function () { Heap.push = heappush; Heap.pop = heappop; Heap.replace = heapreplace; Heap.pushpop = heappushpop; Heap.heapify = heapify; Heap.updateItem = updateItem; Heap.nlargest = nlargest; Heap.nsmallest = nsmallest; function Heap(cmp) { this.cmp = cmp != null ? cmp : defaultCmp; this.nodes = [] } Heap.prototype.push = function (x) { return heappush(this.nodes, x, this.cmp) }; Heap.prototype.pop = function () { return heappop(this.nodes, this.cmp) }; Heap.prototype.peek = function () { return this.nodes[0] }; Heap.prototype.contains = function (x) { return this.nodes.indexOf(x) !== -1 }; Heap.prototype.replace = function (x) { return heapreplace(this.nodes, x, this.cmp) }; Heap.prototype.pushpop = function (x) { return heappushpop(this.nodes, x, this.cmp) }; Heap.prototype.heapify = function () { return heapify(this.nodes, this.cmp) }; Heap.prototype.updateItem = function (x) { return updateItem(this.nodes, x, this.cmp) }; Heap.prototype.clear = function () { return this.nodes = [] }; Heap.prototype.empty = function () { return this.nodes.length === 0 }; Heap.prototype.size = function () { return this.nodes.length }; Heap.prototype.clone = function () { var heap; heap = new Heap; heap.nodes = this.nodes.slice(0); return heap }; Heap.prototype.toArray = function () { return this.nodes.slice(0) }; Heap.prototype.insert = Heap.prototype.push; Heap.prototype.top = Heap.prototype.peek; Heap.prototype.front = Heap.prototype.peek; Heap.prototype.has = Heap.prototype.contains; Heap.prototype.copy = Heap.prototype.clone; return Heap }(); (function (root, factory) { if (typeof define === "function" && define.amd) { return define([], factory) } else if (typeof exports === "object") { return module.exports = factory() } else { return root.Heap = factory() } })(this, function () { return Heap }) }).call(this) }, {}], 15: [function (require, module, exports) { var process = module.exports = {}; var cachedSetTimeout; var cachedClearTimeout; function defaultSetTimout() { throw new Error("setTimeout has not been defined") } function defaultClearTimeout() { throw new Error("clearTimeout has not been defined") } (function () { try { if (typeof setTimeout === "function") { cachedSetTimeout = setTimeout } else { cachedSetTimeout = defaultSetTimout } } catch (e) { cachedSetTimeout = defaultSetTimout } try { if (typeof clearTimeout === "function") { cachedClearTimeout = clearTimeout } else { cachedClearTimeout = defaultClearTimeout } } catch (e) { cachedClearTimeout = defaultClearTimeout } })(); function runTimeout(fun) { if (cachedSetTimeout === setTimeout) { return setTimeout(fun, 0) } if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) { cachedSetTimeout = setTimeout; return setTimeout(fun, 0) } try { return cachedSetTimeout(fun, 0) } catch (e) { try { return cachedSetTimeout.call(null, fun, 0) } catch (e) { return cachedSetTimeout.call(this, fun, 0) } } } function runClearTimeout(marker) { if (cachedClearTimeout === clearTimeout) { return clearTimeout(marker) } if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) { cachedClearTimeout = clearTimeout; return clearTimeout(marker) } try { return cachedClearTimeout(marker) } catch (e) { try { return cachedClearTimeout.call(null, marker) } catch (e) { return cachedClearTimeout.call(this, marker) } } } var queue = []; var draining = false; var currentQueue; var queueIndex = -1; function cleanUpNextTick() { if (!draining || !currentQueue) { return } draining = false; if (currentQueue.length) { queue = currentQueue.concat(queue) } else { queueIndex = -1 } if (queue.length) { drainQueue() } } function drainQueue() { if (draining) { return } var timeout = runTimeout(cleanUpNextTick); draining = true; var len = queue.length; while (len) { currentQueue = queue; queue = []; while (++queueIndex < len) { if (currentQueue) { currentQueue[queueIndex].run() } } queueIndex = -1; len = queue.length } currentQueue = null; draining = false; runClearTimeout(timeout) } process.nextTick = function (fun) { var args = new Array(arguments.length - 1); if (arguments.length > 1) { for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i] } } queue.push(new Item(fun, args)); if (queue.length === 1 && !draining) { runTimeout(drainQueue) } }; function Item(fun, array) { this.fun = fun; this.array = array } Item.prototype.run = function () { this.fun.apply(null, this.array) }; process.title = "browser"; process.browser = true; process.env = {}; process.argv = []; process.version = ""; process.versions = {}; function noop() { } process.on = noop; process.addListener = noop; process.once = noop; process.off = noop; process.removeListener = noop; process.removeAllListeners = noop; process.emit = noop; process.prependListener = noop; process.prependOnceListener = noop; process.listeners = function (name) { return [] }; process.binding = function (name) { throw new Error("process.binding is not supported") }; process.cwd = function () { return "/" }; process.chdir = function (dir) { throw new Error("process.chdir is not supported") }; process.umask = function () { return 0 } }, {}], 16: [function (require, module, exports) { (function (process, global) { (function (global, undefined) { "use strict"; if (global.setImmediate) { return } var nextHandle = 1; var tasksByHandle = {}; var currentlyRunningATask = false; var doc = global.document; var registerImmediate; function setImmediate(callback) { if (typeof callback !== "function") { callback = new Function("" + callback) } var args = new Array(arguments.length - 1); for (var i = 0; i < args.length; i++) { args[i] = arguments[i + 1] } var task = { callback: callback, args: args }; tasksByHandle[nextHandle] = task; registerImmediate(nextHandle); return nextHandle++ } function clearImmediate(handle) { delete tasksByHandle[handle] } function run(task) { var callback = task.callback; var args = task.args; switch (args.length) { case 0: callback(); break; case 1: callback(args[0]); break; case 2: callback(args[0], args[1]); break; case 3: callback(args[0], args[1], args[2]); break; default: callback.apply(undefined, args); break } } function runIfPresent(handle) { if (currentlyRunningATask) { setTimeout(runIfPresent, 0, handle) } else { var task = tasksByHandle[handle]; if (task) { currentlyRunningATask = true; try { run(task) } finally { clearImmediate(handle); currentlyRunningATask = false } } } } function installNextTickImplementation() { registerImmediate = function (handle) { process.nextTick(function () { runIfPresent(handle) }) } } function canUsePostMessage() { if (global.postMessage && !global.importScripts) { var postMessageIsAsynchronous = true; var oldOnMessage = global.onmessage; global.onmessage = function () { postMessageIsAsynchronous = false }; global.postMessage("", "*"); global.onmessage = oldOnMessage; return postMessageIsAsynchronous } } function installPostMessageImplementation() { var messagePrefix = "setImmediate$" + Math.random() + "$"; var onGlobalMessage = function (event) { if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) { runIfPresent(+event.data.slice(messagePrefix.length)) } }; if (global.addEventListener) { global.addEventListener("message", onGlobalMessage, false) } else { global.attachEvent("onmessage", onGlobalMessage) } registerImmediate = function (handle) { global.postMessage(messagePrefix + handle, "*") } } function installMessageChannelImplementation() { var channel = new MessageChannel; channel.port1.onmessage = function (event) { var handle = event.data; runIfPresent(handle) }; registerImmediate = function (handle) { channel.port2.postMessage(handle) } } function installReadyStateChangeImplementation() { var html = doc.documentElement; registerImmediate = function (handle) { var script = doc.createElement("script"); script.onreadystatechange = function () { runIfPresent(handle); script.onreadystatechange = null; html.removeChild(script); script = null }; html.appendChild(script) } } function installSetTimeoutImplementation() { registerImmediate = function (handle) { setTimeout(runIfPresent, 0, handle) } } var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global); attachTo = attachTo && attachTo.setTimeout ? attachTo : global; if ({}.toString.call(global.process) === "[object process]") { installNextTickImplementation() } else if (canUsePostMessage()) { installPostMessageImplementation() } else if (global.MessageChannel) { installMessageChannelImplementation() } else if (doc && "onreadystatechange" in doc.createElement("script")) { installReadyStateChangeImplementation() } else { installSetTimeoutImplementation() } attachTo.setImmediate = setImmediate; attachTo.clearImmediate = clearImmediate })(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self) }).call(this, require("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}) }, { _process: 15 }], 17: [function (require, module, exports) { if (!String.fromCodePoint) { (function () { var defineProperty = function () { try { var object = {}; var $defineProperty = Object.defineProperty; var result = $defineProperty(object, object, object) && $defineProperty } catch (error) { } return result }(); var stringFromCharCode = String.fromCharCode; var floor = Math.floor; var fromCodePoint = function (_) { var MAX_SIZE = 16384; var codeUnits = []; var highSurrogate; var lowSurrogate; var index = -1; var length = arguments.length; if (!length) { return "" } var result = ""; while (++index < length) { var codePoint = Number(arguments[index]); if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) != codePoint) { throw RangeError("Invalid code point: " + codePoint) } if (codePoint <= 65535) { codeUnits.push(codePoint) } else { codePoint -= 65536; highSurrogate = (codePoint >> 10) + 55296; lowSurrogate = codePoint % 1024 + 56320; codeUnits.push(highSurrogate, lowSurrogate) } if (index + 1 == length || codeUnits.length > MAX_SIZE) { result += stringFromCharCode.apply(null, codeUnits); codeUnits.length = 0 } } return result }; if (defineProperty) { defineProperty(String, "fromCodePoint", { value: fromCodePoint, configurable: true, writable: true }) } else { String.fromCodePoint = fromCodePoint } })() } }, {}], 18: [function (require, module, exports) { if (!String.prototype.codePointAt) { (function () { "use strict"; var defineProperty = function () { try { var object = {}; var $defineProperty = Object.defineProperty; var result = $defineProperty(object, object, object) && $defineProperty } catch (error) { } return result }(); var codePointAt = function (position) { if (this == null) { throw TypeError() } var string = String(this); var size = string.length; var index = position ? Number(position) : 0; if (index != index) { index = 0 } if (index < 0 || index >= size) { return undefined } var first = string.charCodeAt(index); var second; if (first >= 55296 && first <= 56319 && size > index + 1) { second = string.charCodeAt(index + 1); if (second >= 56320 && second <= 57343) { return (first - 55296) * 1024 + second - 56320 + 65536 } } return first }; if (defineProperty) { defineProperty(String.prototype, "codePointAt", { value: codePointAt, configurable: true, writable: true }) } else { String.prototype.codePointAt = codePointAt } })() } }, {}]
    }, {}, [1])(1)
});


  var sortedList = [],
  panels = [];


function sortByLikelyHoodDescending(a, b) {
  const likelihoodA = a.likelihood;
  const likelihoodB = b.likelihood;
  let comparison = 0;
  if (likelihoodA > likelihoodB) {
    comparison = 1;
  } else if (likelihoodA < likelihoodB) {
    comparison = -1;
  }
  return comparison * -1;
}

var requestPanelList = new XMLHttpRequest();
requestPanelList.open("GET","/panels/panels.json",true);
requestPanelList.onreadystatechange = function() {
  if( this.readyState == 4) {
    if( this.status == 200) {
      panels = JSON.parse(this.responseText)
    }
    else alert("HTTP error "+this.status+" "+this.statusText);
  }
}
requestPanelList.send();

window.parent.addEventListener("update", eventHandler, true);

function eventHandler(update) {
  panel = update.detail.TITLE
  fullJson = localStorage.getItem('fullJson') ? JSON.parse(localStorage.getItem('fullJson')) : localStorage.setItem('fullJson', '{}');
  fullJson = { ...fullJson, ...update.detail };
  
  localStorage.setItem('fullJson', JSON.stringify(fullJson));

  if (panel){
    panels.forEach(item => {
      sortedList.push({
        panel: item,
        likelihood: fuzzball.ratio(panel, item)
      });
    });
    location.href = "/panels/" + sortedList.sort(sortByLikelyHoodDescending)[0].panel + "/";
  }
}

function init () {
  stripedJson = JSON.parse(localStorage.getItem('fullJson')) ? JSON.parse(localStorage.getItem('fullJson')) : {}
  delete stripedJson.TITLE
  var event = new CustomEvent("update", { "detail": stripedJson });
  document.dispatchEvent(event);
}

window.onload = setTimeout(function(){
  init();
}, 2000);

async function fetchAsync(url) {
  let response = await fetch(url);
  let data = await response.json();
  return data;
}